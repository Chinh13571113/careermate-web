<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/lib/export-job-store.kv.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/export-job-store.kv.ts" />
              <option name="originalContent" value="/**&#10; * Export Job Store - Vercel KV Implementation&#10; *&#10; * Persistent job store for managing PDF export jobs using Vercel KV.&#10; * This replaces the in-memory Map/globalThis approach to work properly&#10; * on Vercel's serverless infrastructure where functions don't share memory.&#10; *&#10; * Features:&#10; * - ✅ Works across multiple serverless function instances&#10; * - ✅ Automatic job expiration after 10 minutes (TTL)&#10; * - ✅ No cleanup intervals needed (KV handles it)&#10; * - ✅ Production-ready for Vercel deployment&#10; *&#10; * Environment Variables (automatically injected by Vercel):&#10; * - KV_REST_API_URL&#10; * - KV_REST_API_TOKEN&#10; * - KV_REST_API_READ_ONLY_TOKEN&#10; */&#10;&#10;import { kv } from &quot;@vercel/kv&quot;;&#10;import { ExportJobState } from &quot;@/types/export-job&quot;;&#10;&#10;// =============================================================================&#10;// Configuration&#10;// =============================================================================&#10;&#10;/** How long to keep jobs in KV before automatic expiration (10 minutes) */&#10;const JOB_TTL_SECONDS = 10 * 60;&#10;&#10;/** KV key prefix for export jobs */&#10;const KEY_PREFIX = &quot;export-pdf-job:&quot;;&#10;&#10;/** Check if KV is properly configured */&#10;const isKVConfigured = Boolean(&#10;  process.env.KV_REST_API_URL &amp;&amp;&#10;  process.env.KV_REST_API_TOKEN &amp;&amp;&#10;  process.env.KV_REST_API_URL !== &quot;asd&quot; &amp;&amp;&#10;  process.env.KV_REST_API_TOKEN !== &quot;asd&quot;&#10;);&#10;&#10;/** In-memory fallback store for development */&#10;const memoryStore = new Map&lt;string, ExportJobState&gt;();&#10;&#10;console.log(`[ExportJobStore:KV] KV Configured: ${isKVConfigured}`);&#10;&#10;// =============================================================================&#10;// Helper Functions&#10;// =============================================================================&#10;&#10;/**&#10; * Generate a KV key for a job ID&#10; */&#10;function getJobKey(jobId: string): string {&#10;  return `${KEY_PREFIX}${jobId}`;&#10;}&#10;&#10;/**&#10; * Generate a UUID v4&#10; */&#10;function generateUUID(): string {&#10;  if (typeof crypto !== &quot;undefined&quot; &amp;&amp; crypto.randomUUID) {&#10;    return crypto.randomUUID();&#10;  }&#10;  return &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(/[xy]/g, function (c) {&#10;    const r = (Math.random() * 16) | 0;&#10;    const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8;&#10;    return v.toString(16);&#10;  });&#10;}&#10;&#10;// =============================================================================&#10;// Store Operations&#10;// =============================================================================&#10;&#10;/**&#10; * Create a new export job in KV&#10; *&#10; * @param resumeId - The resume ID being exported&#10; * @param templateId - The template ID used for export&#10; * @returns The created job state with a unique job ID&#10; */&#10;export async function createJob(&#10;  resumeId: number,&#10;  templateId: string&#10;): Promise&lt;ExportJobState&gt; {&#10;  const jobId = generateUUID();&#10;  const now = Date.now();&#10;&#10;  const job: ExportJobState = {&#10;    jobId,&#10;    status: &quot;processing&quot;,&#10;    resumeId,&#10;    templateId,&#10;    createdAt: now,&#10;    updatedAt: now,&#10;  };&#10;&#10;  // Use KV if configured, otherwise fall back to memory store&#10;  if (isKVConfigured) {&#10;    try {&#10;      await kv.set(getJobKey(jobId), job, { ex: JOB_TTL_SECONDS });&#10;      console.log(`[ExportJobStore:KV] Created job ${jobId} for resume ${resumeId}`);&#10;    } catch (error: any) {&#10;      console.error(`[ExportJobStore:KV] KV storage failed, using memory fallback:`, error.message);&#10;      memoryStore.set(jobId, job);&#10;      console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId}`);&#10;    }&#10;  } else {&#10;    memoryStore.set(jobId, job);&#10;    console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId} (KV not configured)`);&#10;  }&#10;&#10;  return job;&#10;}&#10;&#10;/**&#10; * Get a job by ID from KV&#10; *&#10; * @param jobId - The job ID to retrieve&#10; * @returns The job state or null if not found&#10; */&#10;export async function getJob(jobId: string): Promise&lt;ExportJobState | null&gt; {&#10;  let job: ExportJobState | null = null;&#10;&#10;  // Use KV if configured, otherwise fall back to memory store&#10;  if (isKVConfigured) {&#10;    try {&#10;      job = await kv.get&lt;ExportJobState&gt;(getJobKey(jobId));&#10;      if (job) {&#10;        console.log(`[ExportJobStore:KV] Retrieved job ${jobId}: ${job.status}`);&#10;      } else {&#10;        console.log(`[ExportJobStore:KV] Job ${jobId} not found (may have expired)`);&#10;      }&#10;    } catch (error: any) {&#10;      console.error(`[ExportJobStore:KV] KV retrieval failed, using memory fallback:`, error.message);&#10;      job = memoryStore.get(jobId) || null;&#10;    }&#10;  } else {&#10;    job = memoryStore.get(jobId) || null;&#10;    if (job) {&#10;      console.log(`[ExportJobStore:Memory] Retrieved job ${jobId}: ${job.status}`);&#10;    } else {&#10;      console.log(`[ExportJobStore:Memory] Job ${jobId} not found`);&#10;    }&#10;  }&#10;&#10;  return job;&#10;}&#10;&#10;/**&#10; * Update a job in KV&#10; *&#10; * @param jobId - The job ID to update&#10; * @param updates - Partial updates to apply to the job&#10; */&#10;export async function updateJob(&#10;  jobId: string,&#10;  updates: Partial&lt;Omit&lt;ExportJobState, &quot;jobId&quot; | &quot;createdAt&quot;&gt;&gt;&#10;): Promise&lt;void&gt; {&#10;  const existing = await getJob(jobId);&#10;&#10;  if (!existing) {&#10;    console.warn(`[ExportJobStore] Cannot update non-existent job: ${jobId}`);&#10;    return;&#10;  }&#10;&#10;  const updated: ExportJobState = {&#10;    ...existing,&#10;    ...updates,&#10;    updatedAt: Date.now(),&#10;  };&#10;&#10;  // Use KV if configured, otherwise fall back to memory store&#10;  if (isKVConfigured) {&#10;    try {&#10;      await kv.set(getJobKey(jobId), updated, { ex: JOB_TTL_SECONDS });&#10;      console.log(`[ExportJobStore:KV] Updated job ${jobId}:`, {&#10;        status: updated.status,&#10;        hasFileUrl: !!updated.fileUrl,&#10;        hasError: !!updated.error,&#10;      });&#10;    } catch (error: any) {&#10;      console.error(`[ExportJobStore:KV] KV update failed, using memory fallback:`, error.message);&#10;      memoryStore.set(jobId, updated);&#10;      console.log(`[ExportJobStore:Memory] Updated job ${jobId}`);&#10;    }&#10;  } else {&#10;    memoryStore.set(jobId, updated);&#10;    console.log(`[ExportJobStore:Memory] Updated job ${jobId}:`, {&#10;      status: updated.status,&#10;      hasFileUrl: !!updated.fileUrl,&#10;      hasError: !!updated.error,&#10;    });&#10;  }&#10;}&#10;&#10;/**&#10; * Mark a job as complete with a file URL&#10; * &#10; * @param jobId - The job ID to complete&#10; * @param fileUrl - The Firebase download URL for the generated PDF&#10; */&#10;export async function completeJob(jobId: string, fileUrl: string): Promise&lt;void&gt; {&#10;  await updateJob(jobId, {&#10;    status: &quot;done&quot;,&#10;    fileUrl,&#10;  });&#10;&#10;  console.log(`[ExportJobStore] Job ${jobId} completed with URL: ${fileUrl.substring(0, 50)}...`);&#10;}&#10;&#10;/**&#10; * Mark a job as failed with an error message&#10; * &#10; * @param jobId - The job ID to fail&#10; * @param error - The error message&#10; */&#10;export async function failJob(jobId: string, error: string): Promise&lt;void&gt; {&#10;  await updateJob(jobId, {&#10;    status: &quot;error&quot;,&#10;    error,&#10;  });&#10;&#10;  console.error(`[ExportJobStore] Job ${jobId} failed: ${error}`);&#10;}&#10;&#10;/**&#10; * Delete a job from KV&#10; *&#10; * @param jobId - The job ID to delete&#10; */&#10;export async function deleteJob(jobId: string): Promise&lt;void&gt; {&#10;  // Use KV if configured, otherwise fall back to memory store&#10;  if (isKVConfigured) {&#10;    try {&#10;      await kv.del(getJobKey(jobId));&#10;      console.log(`[ExportJobStore:KV] Deleted job ${jobId}`);&#10;    } catch (error: any) {&#10;      console.error(`[ExportJobStore:KV] KV delete failed, using memory fallback:`, error.message);&#10;      memoryStore.delete(jobId);&#10;      console.log(`[ExportJobStore:Memory] Deleted job ${jobId}`);&#10;    }&#10;  } else {&#10;    memoryStore.delete(jobId);&#10;    console.log(`[ExportJobStore:Memory] Deleted job ${jobId}`);&#10;  }&#10;}&#10;&#10;// =============================================================================&#10;// Export Default Object (for backward compatibility)&#10;// =============================================================================&#10;&#10;export const exportJobStore = {&#10;  createJob,&#10;  getJob,&#10;  updateJob,&#10;  completeJob,&#10;  failJob,&#10;  deleteJob,&#10;};&#10;&#10;export default exportJobStore;&#10;" />
              <option name="updatedContent" value="/**&#10; * Export Job Store - Redis Implementation&#10; *&#10; * Persistent job store for managing PDF export jobs using Redis (Railway).&#10; * This replaces the in-memory Map/globalThis approach to work properly&#10; * on serverless infrastructure where functions don't share memory.&#10; *&#10; * Features:&#10; * - ✅ Works across multiple serverless function instances&#10; * - ✅ Automatic job expiration after 10 minutes (TTL)&#10; * - ✅ No cleanup intervals needed (Redis handles it)&#10; * - ✅ Production-ready for Railway deployment&#10; *&#10; * Environment Variables:&#10; * - REDIS_URL: Redis connection URL (e.g., redis://default:password@host:port)&#10; */&#10;&#10;import Redis from &quot;ioredis&quot;;&#10;import { ExportJobState } from &quot;@/types/export-job&quot;;&#10;&#10;// =============================================================================&#10;// Redis Client&#10;// =============================================================================&#10;&#10;let redis: Redis | null = null;&#10;&#10;/**&#10; * Get or create Redis client instance&#10; */&#10;function getRedisClient(): Redis | null {&#10;  if (!process.env.REDIS_URL) {&#10;    return null;&#10;  }&#10;&#10;  if (!redis) {&#10;    try {&#10;      redis = new Redis(process.env.REDIS_URL, {&#10;        maxRetriesPerRequest: 3,&#10;        retryStrategy(times) {&#10;          return Math.min(times * 50, 2000);&#10;        },&#10;        lazyConnect: false,&#10;        enableOfflineQueue: true,&#10;      });&#10;&#10;      redis.on(&quot;error&quot;, (err) =&gt; {&#10;        console.error(&quot;[ExportJobStore:Redis] Connection error:&quot;, err.message);&#10;      });&#10;&#10;      redis.on(&quot;connect&quot;, () =&gt; {&#10;        console.log(&quot;[ExportJobStore:Redis] Connected successfully&quot;);&#10;      });&#10;    } catch (error) {&#10;      const errorMessage = error instanceof Error ? error.message : String(error);&#10;      console.error(&quot;[ExportJobStore:Redis] Failed to create client:&quot;, errorMessage);&#10;      redis = null;&#10;    }&#10;  }&#10;&#10;  return redis;&#10;}&#10;&#10;// =============================================================================&#10;// Configuration&#10;// =============================================================================&#10;&#10;/** How long to keep jobs in Redis before automatic expiration (10 minutes) */&#10;const JOB_TTL_SECONDS = 10 * 60;&#10;&#10;/** Redis key prefix for export jobs */&#10;const KEY_PREFIX = &quot;export-pdf-job:&quot;;&#10;&#10;/** Check if Redis is properly configured */&#10;const isRedisConfigured = Boolean(process.env.REDIS_URL);&#10;&#10;/** In-memory fallback store for development */&#10;const memoryStore = new Map&lt;string, ExportJobState&gt;();&#10;&#10;console.log(`[ExportJobStore:Redis] Redis Configured: ${isRedisConfigured}`);&#10;&#10;// =============================================================================&#10;// Helper Functions&#10;// =============================================================================&#10;&#10;/**&#10; * Generate a Redis key for a job ID&#10; */&#10;function getJobKey(jobId: string): string {&#10;  return `${KEY_PREFIX}${jobId}`;&#10;}&#10;&#10;/**&#10; * Generate a UUID v4&#10; */&#10;function generateUUID(): string {&#10;  if (typeof crypto !== &quot;undefined&quot; &amp;&amp; crypto.randomUUID) {&#10;    return crypto.randomUUID();&#10;  }&#10;  return &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(/[xy]/g, function (c) {&#10;    const r = (Math.random() * 16) | 0;&#10;    const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8;&#10;    return v.toString(16);&#10;  });&#10;}&#10;&#10;// =============================================================================&#10;// Store Operations&#10;// =============================================================================&#10;&#10;/**&#10; * Create a new export job in Redis&#10; *&#10; * @param resumeId - The resume ID being exported&#10; * @param templateId - The template ID used for export&#10; * @returns The created job state with a unique job ID&#10; */&#10;export async function createJob(&#10;  resumeId: number,&#10;  templateId: string&#10;): Promise&lt;ExportJobState&gt; {&#10;  const jobId = generateUUID();&#10;  const now = Date.now();&#10;&#10;  const job: ExportJobState = {&#10;    jobId,&#10;    status: &quot;processing&quot;,&#10;    resumeId,&#10;    templateId,&#10;    createdAt: now,&#10;    updatedAt: now,&#10;  };&#10;&#10;  // Use Redis if configured, otherwise fall back to memory store&#10;  if (isRedisConfigured) {&#10;    const client = getRedisClient();&#10;    if (client) {&#10;      try {&#10;        await client.setex(getJobKey(jobId), JOB_TTL_SECONDS, JSON.stringify(job));&#10;        console.log(`[ExportJobStore:Redis] Created job ${jobId} for resume ${resumeId}`);&#10;      } catch (error) {&#10;        const errorMessage = error instanceof Error ? error.message : String(error);&#10;        console.error(`[ExportJobStore:Redis] Redis storage failed, using memory fallback:`, errorMessage);&#10;        memoryStore.set(jobId, job);&#10;        console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId}`);&#10;      }&#10;    } else {&#10;      memoryStore.set(jobId, job);&#10;      console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId} (Redis client not available)`);&#10;    }&#10;  } else {&#10;    memoryStore.set(jobId, job);&#10;    console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId} (Redis not configured)`);&#10;  }&#10;&#10;  return job;&#10;}&#10;&#10;/**&#10; * Get a job by ID from Redis&#10; *&#10; * @param jobId - The job ID to retrieve&#10; * @returns The job state or null if not found&#10; */&#10;export async function getJob(jobId: string): Promise&lt;ExportJobState | null&gt; {&#10;  let job: ExportJobState | null = null;&#10;&#10;  // Use Redis if configured, otherwise fall back to memory store&#10;  if (isRedisConfigured) {&#10;    const client = getRedisClient();&#10;    if (client) {&#10;      try {&#10;        const data = await client.get(getJobKey(jobId));&#10;        if (data) {&#10;          job = JSON.parse(data);&#10;          console.log(`[ExportJobStore:Redis] Retrieved job ${jobId}: ${job?.status}`);&#10;        } else {&#10;          console.log(`[ExportJobStore:Redis] Job ${jobId} not found (may have expired)`);&#10;        }&#10;      } catch (error) {&#10;        const errorMessage = error instanceof Error ? error.message : String(error);&#10;        console.error(`[ExportJobStore:Redis] Redis retrieval failed, using memory fallback:`, errorMessage);&#10;        job = memoryStore.get(jobId) || null;&#10;      }&#10;    } else {&#10;      job = memoryStore.get(jobId) || null;&#10;    }&#10;  } else {&#10;    job = memoryStore.get(jobId) || null;&#10;    if (job) {&#10;      console.log(`[ExportJobStore:Memory] Retrieved job ${jobId}: ${job.status}`);&#10;    } else {&#10;      console.log(`[ExportJobStore:Memory] Job ${jobId} not found`);&#10;    }&#10;  }&#10;&#10;  return job;&#10;}&#10;&#10;/**&#10; * Update a job in Redis&#10; *&#10; * @param jobId - The job ID to update&#10; * @param updates - Partial updates to apply to the job&#10; */&#10;export async function updateJob(&#10;  jobId: string,&#10;  updates: Partial&lt;Omit&lt;ExportJobState, &quot;jobId&quot; | &quot;createdAt&quot;&gt;&gt;&#10;): Promise&lt;void&gt; {&#10;  const existing = await getJob(jobId);&#10;&#10;  if (!existing) {&#10;    console.warn(`[ExportJobStore] Cannot update non-existent job: ${jobId}`);&#10;    return;&#10;  }&#10;&#10;  const updated: ExportJobState = {&#10;    ...existing,&#10;    ...updates,&#10;    updatedAt: Date.now(),&#10;  };&#10;&#10;  // Use Redis if configured, otherwise fall back to memory store&#10;  if (isRedisConfigured) {&#10;    const client = getRedisClient();&#10;    if (client) {&#10;      try {&#10;        await client.setex(getJobKey(jobId), JOB_TTL_SECONDS, JSON.stringify(updated));&#10;        console.log(`[ExportJobStore:Redis] Updated job ${jobId}:`, {&#10;          status: updated.status,&#10;          hasFileUrl: !!updated.fileUrl,&#10;          hasError: !!updated.error,&#10;        });&#10;      } catch (error) {&#10;        const errorMessage = error instanceof Error ? error.message : String(error);&#10;        console.error(`[ExportJobStore:Redis] Redis update failed, using memory fallback:`, errorMessage);&#10;        memoryStore.set(jobId, updated);&#10;        console.log(`[ExportJobStore:Memory] Updated job ${jobId}`);&#10;      }&#10;    } else {&#10;      memoryStore.set(jobId, updated);&#10;    }&#10;  } else {&#10;    memoryStore.set(jobId, updated);&#10;    console.log(`[ExportJobStore:Memory] Updated job ${jobId}:`, {&#10;      status: updated.status,&#10;      hasFileUrl: !!updated.fileUrl,&#10;      hasError: !!updated.error,&#10;    });&#10;  }&#10;}&#10;&#10;/**&#10; * Mark a job as complete with a file URL&#10; * &#10; * @param jobId - The job ID to complete&#10; * @param fileUrl - The Firebase download URL for the generated PDF&#10; */&#10;export async function completeJob(jobId: string, fileUrl: string): Promise&lt;void&gt; {&#10;  await updateJob(jobId, {&#10;    status: &quot;done&quot;,&#10;    fileUrl,&#10;  });&#10;&#10;  console.log(`[ExportJobStore] Job ${jobId} completed with URL: ${fileUrl.substring(0, 50)}...`);&#10;}&#10;&#10;/**&#10; * Mark a job as failed with an error message&#10; * &#10; * @param jobId - The job ID to fail&#10; * @param error - The error message&#10; */&#10;export async function failJob(jobId: string, error: string): Promise&lt;void&gt; {&#10;  await updateJob(jobId, {&#10;    status: &quot;error&quot;,&#10;    error,&#10;  });&#10;&#10;  console.error(`[ExportJobStore] Job ${jobId} failed: ${error}`);&#10;}&#10;&#10;/**&#10; * Delete a job from Redis&#10; *&#10; * @param jobId - The job ID to delete&#10; */&#10;export async function deleteJob(jobId: string): Promise&lt;void&gt; {&#10;  // Use Redis if configured, otherwise fall back to memory store&#10;  if (isRedisConfigured) {&#10;    const client = getRedisClient();&#10;    if (client) {&#10;      try {&#10;        await client.del(getJobKey(jobId));&#10;        console.log(`[ExportJobStore:Redis] Deleted job ${jobId}`);&#10;      } catch (error) {&#10;        const errorMessage = error instanceof Error ? error.message : String(error);&#10;        console.error(`[ExportJobStore:Redis] Redis delete failed, using memory fallback:`, errorMessage);&#10;        memoryStore.delete(jobId);&#10;        console.log(`[ExportJobStore:Memory] Deleted job ${jobId}`);&#10;      }&#10;    } else {&#10;      memoryStore.delete(jobId);&#10;    }&#10;  } else {&#10;    memoryStore.delete(jobId);&#10;    console.log(`[ExportJobStore:Memory] Deleted job ${jobId}`);&#10;  }&#10;}&#10;&#10;// =============================================================================&#10;// Export Default Object (for backward compatibility)&#10;// =============================================================================&#10;&#10;export const exportJobStore = {&#10;  createJob,&#10;  getJob,&#10;  updateJob,&#10;  completeJob,&#10;  failJob,&#10;  deleteJob,&#10;};&#10;&#10;export default exportJobStore;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>