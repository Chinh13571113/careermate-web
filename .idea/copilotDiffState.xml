<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/lib/export-job-store.kv.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/export-job-store.kv.ts" />
              <option name="originalContent" value="/**&#10; * Export Job Store - Vercel KV Implementation&#10; *&#10; * Persistent job store for managing PDF export jobs using Vercel KV.&#10; * This replaces the in-memory Map/globalThis approach to work properly&#10; * on Vercel's serverless infrastructure where functions don't share memory.&#10; *&#10; * Features:&#10; * - ✅ Works across multiple serverless function instances&#10; * - ✅ Automatic job expiration after 10 minutes (TTL)&#10; * - ✅ No cleanup intervals needed (KV handles it)&#10; * - ✅ Production-ready for Vercel deployment&#10; *&#10; * Environment Variables (automatically injected by Vercel):&#10; * - KV_REST_API_URL&#10; * - KV_REST_API_TOKEN&#10; * - KV_REST_API_READ_ONLY_TOKEN&#10; */&#10;&#10;import { kv } from &quot;@vercel/kv&quot;;&#10;import { ExportJobState } from &quot;@/types/export-job&quot;;&#10;&#10;// =============================================================================&#10;// Configuration&#10;// =============================================================================&#10;&#10;/** How long to keep jobs in KV before automatic expiration (10 minutes) */&#10;const JOB_TTL_SECONDS = 10 * 60;&#10;&#10;/** KV key prefix for export jobs */&#10;const KEY_PREFIX = &quot;export-pdf-job:&quot;;&#10;&#10;/** Check if KV is properly configured */&#10;const isKVConfigured = Boolean(&#10;  process.env.KV_REST_API_URL &amp;&amp;&#10;  process.env.KV_REST_API_TOKEN &amp;&amp;&#10;  process.env.KV_REST_API_URL !== &quot;asd&quot; &amp;&amp;&#10;  process.env.KV_REST_API_TOKEN !== &quot;asd&quot;&#10;);&#10;&#10;/** In-memory fallback store for development */&#10;const memoryStore = new Map&lt;string, ExportJobState&gt;();&#10;&#10;console.log(`[ExportJobStore:KV] KV Configured: ${isKVConfigured}`);&#10;&#10;// =============================================================================&#10;// Helper Functions&#10;// =============================================================================&#10;&#10;/**&#10; * Generate a KV key for a job ID&#10; */&#10;function getJobKey(jobId: string): string {&#10;  return `${KEY_PREFIX}${jobId}`;&#10;}&#10;&#10;/**&#10; * Generate a UUID v4&#10; */&#10;function generateUUID(): string {&#10;  if (typeof crypto !== &quot;undefined&quot; &amp;&amp; crypto.randomUUID) {&#10;    return crypto.randomUUID();&#10;  }&#10;  return &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(/[xy]/g, function (c) {&#10;    const r = (Math.random() * 16) | 0;&#10;    const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8;&#10;    return v.toString(16);&#10;  });&#10;}&#10;&#10;// =============================================================================&#10;// Store Operations&#10;// =============================================================================&#10;&#10;/**&#10; * Create a new export job in KV&#10; *&#10; * @param resumeId - The resume ID being exported&#10; * @param templateId - The template ID used for export&#10; * @returns The created job state with a unique job ID&#10; */&#10;export async function createJob(&#10;  resumeId: number,&#10;  templateId: string&#10;): Promise&lt;ExportJobState&gt; {&#10;  const jobId = generateUUID();&#10;  const now = Date.now();&#10;&#10;  const job: ExportJobState = {&#10;    jobId,&#10;    status: &quot;processing&quot;,&#10;    resumeId,&#10;    templateId,&#10;    createdAt: now,&#10;    updatedAt: now,&#10;  };&#10;&#10;  // Use KV if configured, otherwise fall back to memory store&#10;  if (isKVConfigured) {&#10;    try {&#10;      await kv.set(getJobKey(jobId), job, { ex: JOB_TTL_SECONDS });&#10;      console.log(`[ExportJobStore:KV] Created job ${jobId} for resume ${resumeId}`);&#10;    } catch (error: any) {&#10;      console.error(`[ExportJobStore:KV] KV storage failed, using memory fallback:`, error.message);&#10;      memoryStore.set(jobId, job);&#10;      console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId}`);&#10;    }&#10;  } else {&#10;    memoryStore.set(jobId, job);&#10;    console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId} (KV not configured)`);&#10;  }&#10;&#10;  return job;&#10;}&#10;&#10;/**&#10; * Get a job by ID from KV&#10; *&#10; * @param jobId - The job ID to retrieve&#10; * @returns The job state or null if not found&#10; */&#10;export async function getJob(jobId: string): Promise&lt;ExportJobState | null&gt; {&#10;  let job: ExportJobState | null = null;&#10;&#10;  // Use KV if configured, otherwise fall back to memory store&#10;  if (isKVConfigured) {&#10;    try {&#10;      job = await kv.get&lt;ExportJobState&gt;(getJobKey(jobId));&#10;      if (job) {&#10;        console.log(`[ExportJobStore:KV] Retrieved job ${jobId}: ${job.status}`);&#10;      } else {&#10;        console.log(`[ExportJobStore:KV] Job ${jobId} not found (may have expired)`);&#10;      }&#10;    } catch (error: any) {&#10;      console.error(`[ExportJobStore:KV] KV retrieval failed, using memory fallback:`, error.message);&#10;      job = memoryStore.get(jobId) || null;&#10;    }&#10;  } else {&#10;    job = memoryStore.get(jobId) || null;&#10;    if (job) {&#10;      console.log(`[ExportJobStore:Memory] Retrieved job ${jobId}: ${job.status}`);&#10;    } else {&#10;      console.log(`[ExportJobStore:Memory] Job ${jobId} not found`);&#10;    }&#10;  }&#10;&#10;  return job;&#10;}&#10;&#10;/**&#10; * Update a job in KV&#10; *&#10; * @param jobId - The job ID to update&#10; * @param updates - Partial updates to apply to the job&#10; */&#10;export async function updateJob(&#10;  jobId: string,&#10;  updates: Partial&lt;Omit&lt;ExportJobState, &quot;jobId&quot; | &quot;createdAt&quot;&gt;&gt;&#10;): Promise&lt;void&gt; {&#10;  const existing = await getJob(jobId);&#10;&#10;  if (!existing) {&#10;    console.warn(`[ExportJobStore] Cannot update non-existent job: ${jobId}`);&#10;    return;&#10;  }&#10;&#10;  const updated: ExportJobState = {&#10;    ...existing,&#10;    ...updates,&#10;    updatedAt: Date.now(),&#10;  };&#10;&#10;  // Use KV if configured, otherwise fall back to memory store&#10;  if (isKVConfigured) {&#10;    try {&#10;      await kv.set(getJobKey(jobId), updated, { ex: JOB_TTL_SECONDS });&#10;      console.log(`[ExportJobStore:KV] Updated job ${jobId}:`, {&#10;        status: updated.status,&#10;        hasFileUrl: !!updated.fileUrl,&#10;        hasError: !!updated.error,&#10;      });&#10;    } catch (error: any) {&#10;      console.error(`[ExportJobStore:KV] KV update failed, using memory fallback:`, error.message);&#10;      memoryStore.set(jobId, updated);&#10;      console.log(`[ExportJobStore:Memory] Updated job ${jobId}`);&#10;    }&#10;  } else {&#10;    memoryStore.set(jobId, updated);&#10;    console.log(`[ExportJobStore:Memory] Updated job ${jobId}:`, {&#10;      status: updated.status,&#10;      hasFileUrl: !!updated.fileUrl,&#10;      hasError: !!updated.error,&#10;    });&#10;  }&#10;}&#10;&#10;/**&#10; * Mark a job as complete with a file URL&#10; * &#10; * @param jobId - The job ID to complete&#10; * @param fileUrl - The Firebase download URL for the generated PDF&#10; */&#10;export async function completeJob(jobId: string, fileUrl: string): Promise&lt;void&gt; {&#10;  await updateJob(jobId, {&#10;    status: &quot;done&quot;,&#10;    fileUrl,&#10;  });&#10;&#10;  console.log(`[ExportJobStore] Job ${jobId} completed with URL: ${fileUrl.substring(0, 50)}...`);&#10;}&#10;&#10;/**&#10; * Mark a job as failed with an error message&#10; * &#10; * @param jobId - The job ID to fail&#10; * @param error - The error message&#10; */&#10;export async function failJob(jobId: string, error: string): Promise&lt;void&gt; {&#10;  await updateJob(jobId, {&#10;    status: &quot;error&quot;,&#10;    error,&#10;  });&#10;&#10;  console.error(`[ExportJobStore] Job ${jobId} failed: ${error}`);&#10;}&#10;&#10;/**&#10; * Delete a job from KV&#10; *&#10; * @param jobId - The job ID to delete&#10; */&#10;export async function deleteJob(jobId: string): Promise&lt;void&gt; {&#10;  // Use KV if configured, otherwise fall back to memory store&#10;  if (isKVConfigured) {&#10;    try {&#10;      await kv.del(getJobKey(jobId));&#10;      console.log(`[ExportJobStore:KV] Deleted job ${jobId}`);&#10;    } catch (error: any) {&#10;      console.error(`[ExportJobStore:KV] KV delete failed, using memory fallback:`, error.message);&#10;      memoryStore.delete(jobId);&#10;      console.log(`[ExportJobStore:Memory] Deleted job ${jobId}`);&#10;    }&#10;  } else {&#10;    memoryStore.delete(jobId);&#10;    console.log(`[ExportJobStore:Memory] Deleted job ${jobId}`);&#10;  }&#10;}&#10;&#10;// =============================================================================&#10;// Export Default Object (for backward compatibility)&#10;// =============================================================================&#10;&#10;export const exportJobStore = {&#10;  createJob,&#10;  getJob,&#10;  updateJob,&#10;  completeJob,&#10;  failJob,&#10;  deleteJob,&#10;};&#10;&#10;export default exportJobStore;&#10;" />
              <option name="updatedContent" value="/**&#10; * Export Job Store - Redis Implementation&#10; *&#10; * Persistent job store for managing PDF export jobs using Redis (Railway).&#10; * This replaces the in-memory Map/globalThis approach to work properly&#10; * on serverless infrastructure where functions don't share memory.&#10; *&#10; * Features:&#10; * - ✅ Works across multiple serverless function instances&#10; * - ✅ Automatic job expiration after 10 minutes (TTL)&#10; * - ✅ No cleanup intervals needed (Redis handles it)&#10; * - ✅ Production-ready for Railway deployment&#10; *&#10; * Environment Variables:&#10; * - REDIS_URL: Redis connection URL (e.g., redis://default:password@host:port)&#10; */&#10;&#10;import Redis from &quot;ioredis&quot;;&#10;import { ExportJobState } from &quot;@/types/export-job&quot;;&#10;&#10;// =============================================================================&#10;// Redis Client&#10;// =============================================================================&#10;&#10;let redis: Redis | null = null;&#10;&#10;/**&#10; * Get or create Redis client instance&#10; */&#10;function getRedisClient(): Redis | null {&#10;  if (!process.env.REDIS_URL) {&#10;    return null;&#10;  }&#10;&#10;  if (!redis) {&#10;    try {&#10;      redis = new Redis(process.env.REDIS_URL, {&#10;        maxRetriesPerRequest: 3,&#10;        retryStrategy(times) {&#10;          return Math.min(times * 50, 2000);&#10;        },&#10;        lazyConnect: false,&#10;        enableOfflineQueue: true,&#10;      });&#10;&#10;      redis.on(&quot;error&quot;, (err) =&gt; {&#10;        console.error(&quot;[ExportJobStore:Redis] Connection error:&quot;, err.message);&#10;      });&#10;&#10;      redis.on(&quot;connect&quot;, () =&gt; {&#10;        console.log(&quot;[ExportJobStore:Redis] Connected successfully&quot;);&#10;      });&#10;    } catch (error) {&#10;      const errorMessage = error instanceof Error ? error.message : String(error);&#10;      console.error(&quot;[ExportJobStore:Redis] Failed to create client:&quot;, errorMessage);&#10;      redis = null;&#10;    }&#10;  }&#10;&#10;  return redis;&#10;}&#10;&#10;// =============================================================================&#10;// Configuration&#10;// =============================================================================&#10;&#10;/** How long to keep jobs in Redis before automatic expiration (10 minutes) */&#10;const JOB_TTL_SECONDS = 10 * 60;&#10;&#10;/** Redis key prefix for export jobs */&#10;const KEY_PREFIX = &quot;export-pdf-job:&quot;;&#10;&#10;/** Check if Redis is properly configured */&#10;const isRedisConfigured = Boolean(process.env.REDIS_URL);&#10;&#10;/** In-memory fallback store for development */&#10;const memoryStore = new Map&lt;string, ExportJobState&gt;();&#10;&#10;console.log(`[ExportJobStore:Redis] Redis Configured: ${isRedisConfigured}`);&#10;&#10;// =============================================================================&#10;// Helper Functions&#10;// =============================================================================&#10;&#10;/**&#10; * Generate a Redis key for a job ID&#10; */&#10;function getJobKey(jobId: string): string {&#10;  return `${KEY_PREFIX}${jobId}`;&#10;}&#10;&#10;/**&#10; * Generate a UUID v4&#10; */&#10;function generateUUID(): string {&#10;  if (typeof crypto !== &quot;undefined&quot; &amp;&amp; crypto.randomUUID) {&#10;    return crypto.randomUUID();&#10;  }&#10;  return &quot;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&quot;.replace(/[xy]/g, function (c) {&#10;    const r = (Math.random() * 16) | 0;&#10;    const v = c === &quot;x&quot; ? r : (r &amp; 0x3) | 0x8;&#10;    return v.toString(16);&#10;  });&#10;}&#10;&#10;// =============================================================================&#10;// Store Operations&#10;// =============================================================================&#10;&#10;/**&#10; * Create a new export job in Redis&#10; *&#10; * @param resumeId - The resume ID being exported&#10; * @param templateId - The template ID used for export&#10; * @returns The created job state with a unique job ID&#10; */&#10;export async function createJob(&#10;  resumeId: number,&#10;  templateId: string&#10;): Promise&lt;ExportJobState&gt; {&#10;  const jobId = generateUUID();&#10;  const now = Date.now();&#10;&#10;  const job: ExportJobState = {&#10;    jobId,&#10;    status: &quot;processing&quot;,&#10;    resumeId,&#10;    templateId,&#10;    createdAt: now,&#10;    updatedAt: now,&#10;  };&#10;&#10;  // Use Redis if configured, otherwise fall back to memory store&#10;  if (isRedisConfigured) {&#10;    const client = getRedisClient();&#10;    if (client) {&#10;      try {&#10;        await client.setex(getJobKey(jobId), JOB_TTL_SECONDS, JSON.stringify(job));&#10;        console.log(`[ExportJobStore:Redis] Created job ${jobId} for resume ${resumeId}`);&#10;      } catch (error) {&#10;        const errorMessage = error instanceof Error ? error.message : String(error);&#10;        console.error(`[ExportJobStore:Redis] Redis storage failed, using memory fallback:`, errorMessage);&#10;        memoryStore.set(jobId, job);&#10;        console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId}`);&#10;      }&#10;    } else {&#10;      memoryStore.set(jobId, job);&#10;      console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId} (Redis client not available)`);&#10;    }&#10;  } else {&#10;    memoryStore.set(jobId, job);&#10;    console.log(`[ExportJobStore:Memory] Created job ${jobId} for resume ${resumeId} (Redis not configured)`);&#10;  }&#10;&#10;  return job;&#10;}&#10;&#10;/**&#10; * Get a job by ID from Redis&#10; *&#10; * @param jobId - The job ID to retrieve&#10; * @returns The job state or null if not found&#10; */&#10;export async function getJob(jobId: string): Promise&lt;ExportJobState | null&gt; {&#10;  let job: ExportJobState | null = null;&#10;&#10;  // Use Redis if configured, otherwise fall back to memory store&#10;  if (isRedisConfigured) {&#10;    const client = getRedisClient();&#10;    if (client) {&#10;      try {&#10;        const data = await client.get(getJobKey(jobId));&#10;        if (data) {&#10;          job = JSON.parse(data);&#10;          console.log(`[ExportJobStore:Redis] Retrieved job ${jobId}: ${job?.status}`);&#10;        } else {&#10;          console.log(`[ExportJobStore:Redis] Job ${jobId} not found (may have expired)`);&#10;        }&#10;      } catch (error) {&#10;        const errorMessage = error instanceof Error ? error.message : String(error);&#10;        console.error(`[ExportJobStore:Redis] Redis retrieval failed, using memory fallback:`, errorMessage);&#10;        job = memoryStore.get(jobId) || null;&#10;      }&#10;    } else {&#10;      job = memoryStore.get(jobId) || null;&#10;    }&#10;  } else {&#10;    job = memoryStore.get(jobId) || null;&#10;    if (job) {&#10;      console.log(`[ExportJobStore:Memory] Retrieved job ${jobId}: ${job.status}`);&#10;    } else {&#10;      console.log(`[ExportJobStore:Memory] Job ${jobId} not found`);&#10;    }&#10;  }&#10;&#10;  return job;&#10;}&#10;&#10;/**&#10; * Update a job in Redis&#10; *&#10; * @param jobId - The job ID to update&#10; * @param updates - Partial updates to apply to the job&#10; */&#10;export async function updateJob(&#10;  jobId: string,&#10;  updates: Partial&lt;Omit&lt;ExportJobState, &quot;jobId&quot; | &quot;createdAt&quot;&gt;&gt;&#10;): Promise&lt;void&gt; {&#10;  const existing = await getJob(jobId);&#10;&#10;  if (!existing) {&#10;    console.warn(`[ExportJobStore] Cannot update non-existent job: ${jobId}`);&#10;    return;&#10;  }&#10;&#10;  const updated: ExportJobState = {&#10;    ...existing,&#10;    ...updates,&#10;    updatedAt: Date.now(),&#10;  };&#10;&#10;  // Use Redis if configured, otherwise fall back to memory store&#10;  if (isRedisConfigured) {&#10;    const client = getRedisClient();&#10;    if (client) {&#10;      try {&#10;        await client.setex(getJobKey(jobId), JOB_TTL_SECONDS, JSON.stringify(updated));&#10;        console.log(`[ExportJobStore:Redis] Updated job ${jobId}:`, {&#10;          status: updated.status,&#10;          hasFileUrl: !!updated.fileUrl,&#10;          hasError: !!updated.error,&#10;        });&#10;      } catch (error) {&#10;        const errorMessage = error instanceof Error ? error.message : String(error);&#10;        console.error(`[ExportJobStore:Redis] Redis update failed, using memory fallback:`, errorMessage);&#10;        memoryStore.set(jobId, updated);&#10;        console.log(`[ExportJobStore:Memory] Updated job ${jobId}`);&#10;      }&#10;    } else {&#10;      memoryStore.set(jobId, updated);&#10;    }&#10;  } else {&#10;    memoryStore.set(jobId, updated);&#10;    console.log(`[ExportJobStore:Memory] Updated job ${jobId}:`, {&#10;      status: updated.status,&#10;      hasFileUrl: !!updated.fileUrl,&#10;      hasError: !!updated.error,&#10;    });&#10;  }&#10;}&#10;&#10;/**&#10; * Mark a job as complete with a file URL&#10; * &#10; * @param jobId - The job ID to complete&#10; * @param fileUrl - The Firebase download URL for the generated PDF&#10; */&#10;export async function completeJob(jobId: string, fileUrl: string): Promise&lt;void&gt; {&#10;  await updateJob(jobId, {&#10;    status: &quot;done&quot;,&#10;    fileUrl,&#10;  });&#10;&#10;  console.log(`[ExportJobStore] Job ${jobId} completed with URL: ${fileUrl.substring(0, 50)}...`);&#10;}&#10;&#10;/**&#10; * Mark a job as failed with an error message&#10; * &#10; * @param jobId - The job ID to fail&#10; * @param error - The error message&#10; */&#10;export async function failJob(jobId: string, error: string): Promise&lt;void&gt; {&#10;  await updateJob(jobId, {&#10;    status: &quot;error&quot;,&#10;    error,&#10;  });&#10;&#10;  console.error(`[ExportJobStore] Job ${jobId} failed: ${error}`);&#10;}&#10;&#10;/**&#10; * Delete a job from Redis&#10; *&#10; * @param jobId - The job ID to delete&#10; */&#10;export async function deleteJob(jobId: string): Promise&lt;void&gt; {&#10;  // Use Redis if configured, otherwise fall back to memory store&#10;  if (isRedisConfigured) {&#10;    const client = getRedisClient();&#10;    if (client) {&#10;      try {&#10;        await client.del(getJobKey(jobId));&#10;        console.log(`[ExportJobStore:Redis] Deleted job ${jobId}`);&#10;      } catch (error) {&#10;        const errorMessage = error instanceof Error ? error.message : String(error);&#10;        console.error(`[ExportJobStore:Redis] Redis delete failed, using memory fallback:`, errorMessage);&#10;        memoryStore.delete(jobId);&#10;        console.log(`[ExportJobStore:Memory] Deleted job ${jobId}`);&#10;      }&#10;    } else {&#10;      memoryStore.delete(jobId);&#10;    }&#10;  } else {&#10;    memoryStore.delete(jobId);&#10;    console.log(`[ExportJobStore:Memory] Deleted job ${jobId}`);&#10;  }&#10;}&#10;&#10;// =============================================================================&#10;// Export Default Object (for backward compatibility)&#10;// =============================================================================&#10;&#10;export const exportJobStore = {&#10;  createJob,&#10;  getJob,&#10;  updateJob,&#10;  completeJob,&#10;  failJob,&#10;  deleteJob,&#10;};&#10;&#10;export default exportJobStore;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/firebase-upload.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/firebase-upload.ts" />
              <option name="originalContent" value="import { ref, uploadBytes, getDownloadURL, deleteObject } from &quot;firebase/storage&quot;;&#10;import { storage } from &quot;@/lib/firebase&quot;;&#10;&#10;// Constants for storage paths&#10;const CV_ROOT = 'careermate-files/candidates';&#10;&#10;/**&#10; * Result type for upload functions that return both path and URL&#10; */&#10;export interface UploadResult {&#10;  /** The storage path (recommended to store in database) */&#10;  storagePath: string;&#10;  /** The download URL (for immediate display, may expire) */&#10;  downloadUrl: string;&#10;}&#10;&#10;/**&#10; * Generate avatar storage path&#10; */&#10;function getAvatarStoragePath(candidateId: string, filename: string): string {&#10;  return `${CV_ROOT}/${candidateId}/avatar/${filename}`;&#10;}&#10;&#10;/**&#10; * Generate CV storage path&#10; */&#10;function getCvStoragePath(candidateId: string, filename: string): string {&#10;  return `${CV_ROOT}/${candidateId}/cv/${filename}`;&#10;}&#10;&#10;/**&#10; * Upload avatar to Firebase Storage (public)&#10; * Path: /careermate-files/candidates/{candidateId}/avatar/{fileName}&#10; * &#10; * @param candidateId - The candidate's numeric ID (NOT email)&#10; * @param file - The image file to upload&#10; * @returns UploadResult with both storagePath and downloadUrl&#10; */&#10;export async function uploadAvatar(candidateId: string, file: File): Promise&lt;UploadResult&gt; {&#10;  try {&#10;    const fileName = `${Date.now()}_${file.name}`;&#10;    const storagePath = getAvatarStoragePath(candidateId, fileName);&#10;    const fileRef = ref(storage, storagePath);&#10;    &#10;    await uploadBytes(fileRef, file);&#10;    const downloadUrl = await getDownloadURL(fileRef);&#10;    &#10;    console.log(&quot;✅ Avatar uploaded:&quot;, { storagePath, downloadUrl });&#10;    &#10;    return {&#10;      storagePath,&#10;      downloadUrl,&#10;    };&#10;  } catch (error) {&#10;    console.error(&quot;Error uploading avatar:&quot;, error);&#10;    throw new Error(&quot;Failed to upload avatar&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload avatar and return only URL (for backward compatibility)&#10; * @deprecated Use uploadAvatar() which returns both path and URL&#10; */&#10;export async function uploadAvatarUrl(candidateId: string, file: File): Promise&lt;string&gt; {&#10;  const result = await uploadAvatar(candidateId, file);&#10;  return result.downloadUrl;&#10;}&#10;&#10;/**&#10; * Upload CV to Firebase Storage (private)&#10; * Path: /careermate-files/candidates/{userId}/cv/{fileName}&#10; */&#10;export async function uploadCV(userId: string, file: File): Promise&lt;string&gt; {&#10;  try {&#10;    const fileName = `${Date.now()}_${file.name}`;&#10;    const fileRef = ref(storage, `careermate-files/candidates/${userId}/cv/${fileName}`);&#10;    &#10;    await uploadBytes(fileRef, file);&#10;    const downloadURL = await getDownloadURL(fileRef);&#10;    &#10;    return downloadURL;&#10;  } catch (error) {&#10;    console.error(&quot;Error uploading CV:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload CV PDF from Blob to Firebase Storage (private)&#10; * Used after generating PDF with Puppeteer&#10; * Path: /careermate-files/candidates/{userId}/cv/{fileName}&#10; */&#10;export async function uploadCVPDF(&#10;  userId: string, &#10;  pdfBlob: Blob, &#10;  customFileName?: string&#10;): Promise&lt;string&gt; {&#10;  try {&#10;    const timestamp = Date.now();&#10;    const fileName = customFileName &#10;      ? `${timestamp}_${customFileName}.pdf`&#10;      : `cv_${timestamp}.pdf`;&#10;    &#10;    const fileRef = ref(storage, `careermate-files/candidates/${userId}/cv/${fileName}`);&#10;    &#10;    // Upload blob với metadata&#10;    await uploadBytes(fileRef, pdfBlob, {&#10;      contentType: &quot;application/pdf&quot;,&#10;      customMetadata: {&#10;        uploadedAt: new Date().toISOString(),&#10;        type: &quot;generated-cv&quot;,&#10;      },&#10;    });&#10;    &#10;    const downloadURL = await getDownloadURL(fileRef);&#10;    &#10;    console.log(&quot;✅ CV PDF uploaded successfully:&quot;, downloadURL);&#10;    return downloadURL;&#10;  } catch (error) {&#10;    console.error(&quot;❌ Error uploading CV PDF:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV PDF to Firebase&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Delete file from Firebase Storage&#10; */&#10;export async function deleteFile(fileUrl: string): Promise&lt;void&gt; {&#10;  try {&#10;    const fileRef = ref(storage, fileUrl);&#10;    await deleteObject(fileRef);&#10;  } catch (error) {&#10;    console.error(&quot;Error deleting file:&quot;, error);&#10;    throw new Error(&quot;Failed to delete file&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload CV file to Firebase Storage with metadata&#10; * Path: careermate-files/candidates/{candidateId}/cv/{generatedFilename}&#10; * @param candidateId - The candidate's ID&#10; * @param file - The CV file to upload&#10; * @returns Metadata object (does NOT include File/Blob)&#10; */&#10;export async function uploadCvFile(candidateId: string, file: File) {&#10;  try {&#10;    // Extract file extension&#10;    const ext = file.name.split('.').pop() || 'pdf';&#10;    &#10;    // Generate unique filename using crypto.randomUUID()&#10;    const filename = crypto.randomUUID() + '.' + ext;&#10;    &#10;    // Build storage path using helper function&#10;    const path = getCvStoragePath(candidateId, filename);&#10;    &#10;    // Upload to Firebase Storage&#10;    const storageRef = ref(storage, path);&#10;    await uploadBytes(storageRef, file);&#10;    const downloadUrl = await getDownloadURL(storageRef);&#10;    &#10;    // Return ONLY metadata (no File/Blob)&#10;    return {&#10;      id: filename,&#10;      candidateId,&#10;      storagePath: path,&#10;      downloadUrl,&#10;      type: 'UPLOADED' as const,&#10;      status: 'READY' as const,&#10;      isDefault: false,&#10;      updatedAt: new Date().toISOString(),&#10;    };&#10;  } catch (error) {&#10;    console.error(&quot;Error uploading CV file:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV file&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload CV for job application to Firebase Storage&#10; * Path: careermate-files/job-applications/{jobId}/{originalName}_CM_{timestamp}.{ext}&#10; * &#10; * @param jobId - The job posting ID&#10; * @param file - The CV file to upload&#10; * @returns UploadResult with storagePath and downloadUrl&#10; */&#10;export async function uploadJobApplicationCV(jobId: string | number, file: File): Promise&lt;UploadResult&gt; {&#10;  try {&#10;    // Extract file info&#10;    const originalName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension&#10;    const ext = file.name.split('.').pop() || 'pdf';&#10;    const timestamp = Date.now();&#10;    &#10;    // Generate filename: {originalName}_CM_{timestamp}.{ext}&#10;    const filename = `${originalName}_CM_${timestamp}.${ext}`;&#10;    &#10;    // Build storage path&#10;    const storagePath = `careermate-files/job-applications/${jobId}/${filename}`;&#10;    &#10;    // Upload to Firebase Storage&#10;    const storageRef = ref(storage, storagePath);&#10;    await uploadBytes(storageRef, file, {&#10;      contentType: file.type || 'application/pdf',&#10;      customMetadata: {&#10;        uploadedAt: new Date().toISOString(),&#10;        originalName: file.name,&#10;        jobId: String(jobId),&#10;        type: 'job-application-cv',&#10;      },&#10;    });&#10;    &#10;    const downloadUrl = await getDownloadURL(storageRef);&#10;    &#10;    console.log(&quot;✅ Job Application CV uploaded:&quot;, { storagePath, downloadUrl });&#10;    &#10;    return {&#10;      storagePath,&#10;      downloadUrl,&#10;    };&#10;  } catch (error) {&#10;    console.error(&quot;❌ Error uploading job application CV:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV for job application&quot;);&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { ref, uploadBytes, getDownloadURL, deleteObject } from &quot;firebase/storage&quot;;&#10;import { storage } from &quot;@/lib/firebase&quot;;&#10;&#10;// Constants for storage paths&#10;const CV_ROOT = 'careermate-files/candidates';&#10;&#10;/**&#10; * Result type for upload functions that return both path and URL&#10; */&#10;export interface UploadResult {&#10;  /** The storage path (recommended to store in database) */&#10;  storagePath: string;&#10;  /** The download URL (for immediate display, may expire) */&#10;  downloadUrl: string;&#10;}&#10;&#10;/**&#10; * Generate avatar storage path&#10; */&#10;function getAvatarStoragePath(candidateId: string, filename: string): string {&#10;  return `${CV_ROOT}/${candidateId}/avatar/${filename}`;&#10;}&#10;&#10;/**&#10; * Generate CV storage path&#10; */&#10;function getCvStoragePath(candidateId: string, filename: string): string {&#10;  return `${CV_ROOT}/${candidateId}/cv/${filename}`;&#10;}&#10;&#10;/**&#10; * Upload avatar to Firebase Storage (public)&#10; * Path: /careermate-files/candidates/{candidateId}/avatar/{fileName}&#10; * &#10; * @param candidateId - The candidate's numeric ID (NOT email)&#10; * @param file - The image file to upload&#10; * @returns UploadResult with both storagePath and downloadUrl&#10; */&#10;export async function uploadAvatar(candidateId: string, file: File): Promise&lt;UploadResult&gt; {&#10;  try {&#10;    // Extract file extension properly&#10;    const ext = file.name.split('.').pop()?.toLowerCase() || 'jpg';&#10;    &#10;    // Sanitize filename: remove extension and special chars&#10;    const sanitizedName = file.name&#10;      .replace(/\.[^/.]+$/, '') // Remove extension&#10;      .replace(/[^a-zA-Z0-9_-]/g, '_') // Replace special chars&#10;      .substring(0, 50); // Limit length&#10;    &#10;    const fileName = `${Date.now()}_${sanitizedName}.${ext}`;&#10;    const storagePath = getAvatarStoragePath(candidateId, fileName);&#10;    const fileRef = ref(storage, storagePath);&#10;    &#10;    await uploadBytes(fileRef, file);&#10;    const downloadUrl = await getDownloadURL(fileRef);&#10;    &#10;    console.log(&quot;✅ Avatar uploaded:&quot;, { storagePath, downloadUrl });&#10;    &#10;    return {&#10;      storagePath,&#10;      downloadUrl,&#10;    };&#10;  } catch (error) {&#10;    console.error(&quot;Error uploading avatar:&quot;, error);&#10;    throw new Error(&quot;Failed to upload avatar&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload avatar and return only URL (for backward compatibility)&#10; * @deprecated Use uploadAvatar() which returns both path and URL&#10; */&#10;export async function uploadAvatarUrl(candidateId: string, file: File): Promise&lt;string&gt; {&#10;  const result = await uploadAvatar(candidateId, file);&#10;  return result.downloadUrl;&#10;}&#10;&#10;/**&#10; * Upload CV to Firebase Storage (private)&#10; * Path: /careermate-files/candidates/{userId}/cv/{fileName}&#10; * &#10; * @returns Storage path (to be saved in database)&#10; */&#10;export async function uploadCV(userId: string, file: File): Promise&lt;string&gt; {&#10;  try {&#10;    // Extract file extension properly&#10;    const ext = file.name.split('.').pop()?.toLowerCase() || 'pdf';&#10;    &#10;    // Sanitize filename&#10;    const sanitizedName = file.name&#10;      .replace(/\.[^/.]+$/, '')&#10;      .replace(/[^a-zA-Z0-9_-]/g, '_')&#10;      .substring(0, 50);&#10;    &#10;    const fileName = `${Date.now()}_${sanitizedName}.${ext}`;&#10;    const storagePath = `careermate-files/candidates/${userId}/cv/${fileName}`;&#10;    const fileRef = ref(storage, storagePath);&#10;    &#10;    await uploadBytes(fileRef, file);&#10;    &#10;    console.log(&quot;✅ CV uploaded:&quot;, storagePath);&#10;    &#10;    // Return storage path, not download URL&#10;    return storagePath;&#10;  } catch (error) {&#10;    console.error(&quot;Error uploading CV:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload CV PDF from Blob to Firebase Storage (private)&#10; * Used after generating PDF with Puppeteer&#10; * Path: /careermate-files/candidates/{userId}/cv/{fileName}&#10; */&#10;export async function uploadCVPDF(&#10;  userId: string, &#10;  pdfBlob: Blob, &#10;  customFileName?: string&#10;): Promise&lt;string&gt; {&#10;  try {&#10;    const timestamp = Date.now();&#10;    const fileName = customFileName &#10;      ? `${timestamp}_${customFileName}.pdf`&#10;      : `cv_${timestamp}.pdf`;&#10;    &#10;    const fileRef = ref(storage, `careermate-files/candidates/${userId}/cv/${fileName}`);&#10;    &#10;    // Upload blob với metadata&#10;    await uploadBytes(fileRef, pdfBlob, {&#10;      contentType: &quot;application/pdf&quot;,&#10;      customMetadata: {&#10;        uploadedAt: new Date().toISOString(),&#10;        type: &quot;generated-cv&quot;,&#10;      },&#10;    });&#10;    &#10;    const downloadURL = await getDownloadURL(fileRef);&#10;    &#10;    console.log(&quot;✅ CV PDF uploaded successfully:&quot;, downloadURL);&#10;    return downloadURL;&#10;  } catch (error) {&#10;    console.error(&quot;❌ Error uploading CV PDF:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV PDF to Firebase&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Delete file from Firebase Storage&#10; */&#10;export async function deleteFile(fileUrl: string): Promise&lt;void&gt; {&#10;  try {&#10;    const fileRef = ref(storage, fileUrl);&#10;    await deleteObject(fileRef);&#10;  } catch (error) {&#10;    console.error(&quot;Error deleting file:&quot;, error);&#10;    throw new Error(&quot;Failed to delete file&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload CV file to Firebase Storage with metadata&#10; * Path: careermate-files/candidates/{candidateId}/cv/{generatedFilename}&#10; * @param candidateId - The candidate's ID&#10; * @param file - The CV file to upload&#10; * @returns Metadata object (does NOT include File/Blob)&#10; */&#10;export async function uploadCvFile(candidateId: string, file: File) {&#10;  try {&#10;    // Extract file extension&#10;    const ext = file.name.split('.').pop() || 'pdf';&#10;    &#10;    // Generate unique filename using crypto.randomUUID()&#10;    const filename = crypto.randomUUID() + '.' + ext;&#10;    &#10;    // Build storage path using helper function&#10;    const path = getCvStoragePath(candidateId, filename);&#10;    &#10;    // Upload to Firebase Storage&#10;    const storageRef = ref(storage, path);&#10;    await uploadBytes(storageRef, file);&#10;    const downloadUrl = await getDownloadURL(storageRef);&#10;    &#10;    // Return ONLY metadata (no File/Blob)&#10;    return {&#10;      id: filename,&#10;      candidateId,&#10;      storagePath: path,&#10;      downloadUrl,&#10;      type: 'UPLOADED' as const,&#10;      status: 'READY' as const,&#10;      isDefault: false,&#10;      updatedAt: new Date().toISOString(),&#10;    };&#10;  } catch (error) {&#10;    console.error(&quot;Error uploading CV file:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV file&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload CV for job application to Firebase Storage&#10; * Path: careermate-files/job-applications/{jobId}/{originalName}_CM_{timestamp}.{ext}&#10; * &#10; * @param jobId - The job posting ID&#10; * @param file - The CV file to upload&#10; * @returns UploadResult with storagePath and downloadUrl&#10; */&#10;export async function uploadJobApplicationCV(jobId: string | number, file: File): Promise&lt;UploadResult&gt; {&#10;  try {&#10;    // Extract file info&#10;    const originalName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension&#10;    const ext = file.name.split('.').pop() || 'pdf';&#10;    const timestamp = Date.now();&#10;    &#10;    // Generate filename: {originalName}_CM_{timestamp}.{ext}&#10;    const filename = `${originalName}_CM_${timestamp}.${ext}`;&#10;    &#10;    // Build storage path&#10;    const storagePath = `careermate-files/job-applications/${jobId}/${filename}`;&#10;    &#10;    // Upload to Firebase Storage&#10;    const storageRef = ref(storage, storagePath);&#10;    await uploadBytes(storageRef, file, {&#10;      contentType: file.type || 'application/pdf',&#10;      customMetadata: {&#10;        uploadedAt: new Date().toISOString(),&#10;        originalName: file.name,&#10;        jobId: String(jobId),&#10;        type: 'job-application-cv',&#10;      },&#10;    });&#10;    &#10;    const downloadUrl = await getDownloadURL(storageRef);&#10;    &#10;    console.log(&quot;✅ Job Application CV uploaded:&quot;, { storagePath, downloadUrl });&#10;    &#10;    return {&#10;      storagePath,&#10;      downloadUrl,&#10;    };&#10;  } catch (error) {&#10;    console.error(&quot;❌ Error uploading job application CV:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV for job application&quot;);&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/services/cvFirebaseService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/services/cvFirebaseService.ts" />
              <option name="originalContent" value="import {&#10;  ref,&#10;  uploadBytes,&#10;  getDownloadURL,&#10;  deleteObject,&#10;} from &quot;firebase/storage&quot;;&#10;import { storage } from &quot;@/lib/firebase&quot;;&#10;&#10;// ===== Type Definitions =====&#10;export type CVType = &quot;CREATED&quot; | &quot;UPLOADED&quot;;&#10;export type CVSource = &quot;upload&quot; | &quot;builder&quot; | &quot;draft&quot;;&#10;export type CVVisibility = &quot;public&quot; | &quot;private&quot;;&#10;export type CVParsedStatus = &quot;processing&quot; | &quot;ready&quot; | &quot;failed&quot;;&#10;export type CVStatus = &quot;DRAFT&quot; | &quot;READY&quot;;&#10;&#10;// ===== CV Interface =====&#10;export interface CV {&#10;  // Core fields (always present)&#10;  id: string;&#10;  name: string;&#10;  type: CVType;&#10;  source?: CVSource; // Optional for compatibility with legacy components&#10;  createdAt: string; // ISO string&#10;  updatedAt: string; // ISO string&#10;  size?: number; // bytes (optional)&#10;  fileSize?: string; // formatted size (e.g., &quot;1.2 MB&quot;) (optional)&#10;  isDefault: boolean;&#10;  visibility?: CVVisibility; // Optional&#10;  privacy?: CVVisibility; // alias for visibility (optional, for compatibility)&#10;  downloadUrl: string;&#10;  fileUrl?: string; // alias for downloadUrl (optional, for compatibility)&#10;  userId?: string; // Optional&#10;  candidateId?: string; // Optional&#10;  storagePath: string; // path in Firebase Storage&#10;  parsedStatus?: CVParsedStatus; // Optional for UI display&#10;  status: CVStatus; // DRAFT or READY&#10;}&#10;&#10;// ===== Constants =====&#10;const CV_ROOT = 'careermate-files/candidates';&#10;const CV_SEPARATOR = '_CM_';&#10;&#10;// ===== Helper Functions =====&#10;&#10;/**&#10; * Sanitize file name: remove unsafe characters, replace spaces with underscores&#10; * &#10; * @param fileName - Original file name&#10; * @returns Sanitized file name&#10; * &#10; * @example&#10; * sanitizeFileName(&quot;My CV (final)!.pdf&quot;) // → &quot;My_CV_final.pdf&quot;&#10; * sanitizeFileName(&quot;Résumé 2024.pdf&quot;) // → &quot;Resume_2024.pdf&quot;&#10; */&#10;function sanitizeFileName(fileName: string): string {&#10;  if (!fileName) {&#10;    return 'file';&#10;  }&#10;&#10;  // Get extension first&#10;  const lastDotIndex = fileName.lastIndexOf('.');&#10;  let nameWithoutExt: string;&#10;  let extension: string;&#10;&#10;  if (lastDotIndex &gt; 0) {&#10;    nameWithoutExt = fileName.substring(0, lastDotIndex);&#10;    extension = fileName.substring(lastDotIndex + 1);&#10;  } else {&#10;    nameWithoutExt = fileName;&#10;    extension = 'pdf';&#10;  }&#10;&#10;  // Remove special characters, replace spaces with underscores&#10;  const sanitized = nameWithoutExt&#10;    .normalize('NFD') // Normalize unicode characters&#10;    .replace(/[\u0300-\u036f]/g, '') // Remove diacritics&#10;    .replace(/[^a-zA-Z0-9\s\-_]/g, '') // Remove special chars except space, hyphen, underscore&#10;    .replace(/\s+/g, '_') // Replace spaces with underscores&#10;    .replace(/_+/g, '_') // Replace multiple underscores with single&#10;    .trim();&#10;&#10;  return sanitized ? `${sanitized}.${extension}` : `file.${extension}`;&#10;}&#10;&#10;/**&#10; * Generate storage file name with timestamp&#10; * Format: [originalName]_CM_[timestamp].[ext]&#10; * &#10; * @param originalFileName - Original file name from user&#10; * @returns Storage file name with timestamp&#10; * &#10; * @example&#10; * generateStorageName(&quot;CV.pdf&quot;) // → &quot;CV_CM_1732702341123.pdf&quot;&#10; * generateStorageName(&quot;My Resume.pdf&quot;) // → &quot;My_Resume_CM_1732702341123.pdf&quot;&#10; */&#10;function generateStorageName(originalFileName: string): string {&#10;  if (!originalFileName) {&#10;    return `file${CV_SEPARATOR}${Date.now()}.pdf`;&#10;  }&#10;&#10;  try {&#10;    // Sanitize first&#10;    const sanitized = sanitizeFileName(originalFileName);&#10;&#10;    // Extract base name and extension&#10;    const lastDotIndex = sanitized.lastIndexOf('.');&#10;    &#10;    let baseName: string;&#10;    let extension: string;&#10;&#10;    if (lastDotIndex &gt; 0) {&#10;      baseName = sanitized.substring(0, lastDotIndex);&#10;      extension = sanitized.substring(lastDotIndex + 1);&#10;    } else {&#10;      baseName = sanitized;&#10;      extension = 'pdf';&#10;    }&#10;&#10;    // Generate timestamp&#10;    const timestamp = Date.now();&#10;&#10;    // Build storage name: [baseName]_CM_[timestamp].[ext]&#10;    return `${baseName}${CV_SEPARATOR}${timestamp}.${extension}`;&#10;  } catch (error) {&#10;    console.error('Error generating storage name:', error);&#10;    return `file${CV_SEPARATOR}${Date.now()}.pdf`;&#10;  }&#10;}&#10;&#10;/**&#10; * Extract original file name from storage name&#10; * Removes the _CM_[timestamp] suffix&#10; * &#10; * @param storageName - The storage file name (e.g., &quot;CV_CM_1732702341123.pdf&quot;)&#10; * @returns Original file name (e.g., &quot;CV.pdf&quot;)&#10; * &#10; * @example&#10; * extractOriginalName(&quot;CV_CM_1732702341123.pdf&quot;) // → &quot;CV.pdf&quot;&#10; * extractOriginalName(&quot;My_Resume_CM_1732702341123.pdf&quot;) // → &quot;My_Resume.pdf&quot;&#10; * extractOriginalName(&quot;CV.pdf&quot;) // → &quot;CV.pdf&quot; (no separator, return as-is)&#10; */&#10;export function extractOriginalName(storageName: string): string {&#10;  if (!storageName) {&#10;    return 'Unknown.pdf';&#10;  }&#10;&#10;  // If no separator found, return as-is&#10;  if (!storageName.includes(CV_SEPARATOR)) {&#10;    return storageName;&#10;  }&#10;&#10;  try {&#10;    // Split at _CM_ separator&#10;    const parts = storageName.split(CV_SEPARATOR);&#10;    &#10;    if (parts.length &lt; 2) {&#10;      return storageName;&#10;    }&#10;&#10;    // Get base name (before _CM_)&#10;    const baseName = parts[0];&#10;    &#10;    // Get the extension from the storage name (after timestamp)&#10;    const lastPart = parts[parts.length - 1]; // &quot;1732702341123.pdf&quot;&#10;    const extMatch = lastPart.match(/\.([^.]+)$/);&#10;    const extension = extMatch ? extMatch[1] : 'pdf';&#10;&#10;    // Reconstruct: baseName + extension&#10;    return `${baseName}.${extension}`;&#10;  } catch (error) {&#10;    console.error('Error extracting original name:', error);&#10;    return storageName;&#10;  }&#10;}&#10;&#10;/**&#10; * Format file size from bytes to human-readable&#10; */&#10;export function formatFileSize(bytes: number): string {&#10;  if (bytes === 0) return &quot;0 Bytes&quot;;&#10;  const k = 1024;&#10;  const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;];&#10;  const i = Math.floor(Math.log(bytes) / Math.log(k));&#10;  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + &quot; &quot; + sizes[i];&#10;}&#10;&#10;/**&#10; * Generate CV storage path&#10; * Path: careermate-files/candidates/{candidateId}/{filename}&#10; */&#10;function getCvStoragePath(candidateId: string, filename: string): string {&#10;  return `${CV_ROOT}/${candidateId}/cv/${filename}`;&#10;}&#10;&#10;// ===== Firebase Storage Functions =====&#10;&#10;/**&#10; * Upload CV file to Firebase Storage with metadata&#10; * Path: candidates/{candidateId}/{storageName}&#10; * &#10; * @param candidateId - The candidate's ID&#10; * @param file - The CV file to upload&#10; * @returns Metadata object with originalName and storageName&#10; * &#10; * @example&#10; * const result = await uploadCvFile(&quot;123&quot;, file);&#10; * // result.originalName → &quot;CV.pdf&quot;&#10; * // result.storageName → &quot;CV_CM_1732702341123.pdf&quot;&#10; * // result.downloadUrl → &quot;https://firebasestorage...&quot;&#10; * // result.fullPath → &quot;candidates/123/CV_CM_1732702341123.pdf&quot;&#10; */&#10;export async function uploadCvFile(candidateId: string, file: File) {&#10;  console.log(&quot; Uploading CV start:&quot;, {&#10;    fileName: file.name,&#10;    fileSize: formatFileSize(file.size),&#10;    fileType: file.type,&#10;    candidateId,&#10;  });&#10;&#10;  // Validate Firebase Storage configuration&#10;  const bucket = process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET;&#10;  if (!bucket) {&#10;    console.error(&quot;❌ NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET is not defined in environment variables&quot;);&#10;    throw new Error(&quot;Firebase Storage bucket is not configured. Please check your .env file.&quot;);&#10;  }&#10;&#10;  // Validate bucket format&#10;  if (!bucket.includes('.firebasestorage.app') &amp;&amp; !bucket.includes('.appspot.com')) {&#10;    console.warn(&quot;⚠️ Firebase Storage bucket format might be invalid:&quot;, bucket);&#10;    console.warn(&quot;Expected format: 'project-id.firebasestorage.app' or 'project-id.appspot.com'&quot;);&#10;  }&#10;&#10;  try {&#10;    // Store original name&#10;    const originalName = file.name;&#10;    &#10;    // Generate storage name: [originalName]_CM_[timestamp].[ext]&#10;    const storageName = generateStorageName(originalName);&#10;    &#10;    console.log(&quot; File names:&quot;, {&#10;      original: originalName,&#10;      storage: storageName,&#10;    });&#10;    &#10;    // Build storage path&#10;    const fullPath = getCvStoragePath(candidateId, storageName);&#10;    &#10;    console.log(&quot; Storage path:&quot;, fullPath);&#10;    &#10;    // Upload to Firebase Storage&#10;    const storageRef = ref(storage, fullPath);&#10;    &#10;    console.log(&quot;⬆️ Uploading bytes to Firebase Storage...&quot;);&#10;    const uploadResult = await uploadBytes(storageRef, file, {&#10;      contentType: file.type,&#10;      customMetadata: {&#10;        candidateId,&#10;        originalName: originalName,&#10;        storageName: storageName,&#10;        uploadedAt: new Date().toISOString(),&#10;      },&#10;    });&#10;    &#10;    console.log(&quot;✅ Upload bytes successful:&quot;, {&#10;      path: uploadResult.ref.fullPath,&#10;      size: uploadResult.metadata.size,&#10;    });&#10;    &#10;    // Get download URL with retry logic (Firebase propagation can be slow)&#10;    let downloadUrl: string | undefined;&#10;    let retries = 3;&#10;    let lastError: Error | undefined;&#10;&#10;    console.log(&quot; Fetching download URL...&quot;);&#10;    &#10;    while (retries &gt; 0 &amp;&amp; !downloadUrl) {&#10;      try {&#10;        downloadUrl = await getDownloadURL(storageRef);&#10;        console.log(&quot;✅ Download URL obtained:&quot;, downloadUrl);&#10;      } catch (error: any) {&#10;        lastError = error;&#10;        retries--;&#10;        &#10;        // Log detailed Firebase error&#10;        console.error(`⚠️ getDownloadURL attempt failed (${3 - retries}/3):`, {&#10;          code: error?.code,&#10;          message: error?.message,&#10;          serverResponse: error?.serverResponse,&#10;          customData: error?.customData,&#10;        });&#10;&#10;        // Check for common Firebase Storage errors&#10;        if (error?.code === 'storage/object-not-found') {&#10;          console.error(&quot;❌ Firebase Storage Error: Object not found. File might not have propagated yet.&quot;);&#10;        } else if (error?.code === 'storage/unauthorized') {&#10;          console.error(&quot;❌ Firebase Storage Error: Permission denied. Check Firebase Storage Rules:&quot;);&#10;          console.error(&quot;   Rules should allow: allow read, write: if request.auth != null;&quot;);&#10;        } else if (error?.code === 'storage/bucket-not-found') {&#10;          console.error(&quot;❌ Firebase Storage Error: Bucket not found. Check NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET:&quot;, bucket);&#10;        }&#10;&#10;        if (retries &gt; 0) {&#10;          console.log(`⏳ Retrying in 1 second... (${retries} attempts left)`);&#10;          await new Promise(resolve =&gt; setTimeout(resolve, 1000));&#10;        }&#10;      }&#10;    }&#10;&#10;    // Final validation: Ensure downloadUrl is not undefined&#10;    if (!downloadUrl) {&#10;      console.error(&quot;❌ CRITICAL: Download URL is undefined after all retries&quot;);&#10;      console.error(&quot;Last error:&quot;, lastError);&#10;      throw new Error(&#10;        `Failed to get download URL after 3 attempts. ${&#10;          lastError?.message || 'Unknown error'&#10;        }. Check Firebase Storage Rules and bucket configuration.`&#10;      );&#10;    }&#10;&#10;    // Construct metadata object&#10;    const metadata = {&#10;      id: storageName,&#10;      name: originalName,&#10;      originalName: originalName,&#10;      storageName: storageName,&#10;      candidateId,&#10;      storagePath: fullPath,&#10;      fullPath: fullPath,&#10;      downloadUrl, // GUARANTEED to be defined here&#10;      type: 'UPLOADED' as const,&#10;      source: 'upload' as const,&#10;      status: 'READY' as const,&#10;      isDefault: false,&#10;      updatedAt: new Date().toISOString(),&#10;      createdAt: new Date().toISOString(),&#10;      size: file.size,&#10;      fileSize: formatFileSize(file.size),&#10;    };&#10;&#10;    console.log(&quot;✅ Firebase upload complete:&quot;, {&#10;      originalName: metadata.originalName,&#10;      storageName: metadata.storageName,&#10;      downloadUrl: metadata.downloadUrl,&#10;      fullPath: metadata.fullPath,&#10;    });&#10;&#10;    return metadata;&#10;  } catch (error: any) {&#10;    console.error(&quot;❌ Error uploading CV file:&quot;, {&#10;      error,&#10;      code: error?.code,&#10;      message: error?.message,&#10;      fileName: file.name,&#10;      candidateId,&#10;    });&#10;&#10;    // Re-throw with more context&#10;    throw new Error(&#10;      `Failed to upload CV file: ${error?.message || 'Unknown error'}. ${&#10;        error?.code ? `Error code: ${error.code}` : ''&#10;      }`&#10;    );&#10;  }&#10;}&#10;&#10;/**&#10; * Upload avatar to Firebase Storage (public)&#10; * Path: /careermate-files/candidates/{userId}/avatar/{fileName}&#10; */&#10;export async function uploadAvatar(userId: string, file: File): Promise&lt;string&gt; {&#10;  try {&#10;    const fileName = `${Date.now()}_${file.name}`;&#10;    const fileRef = ref(storage, `careermate-files/candidates/${userId}/avatar/${fileName}`);&#10;    &#10;    await uploadBytes(fileRef, file);&#10;    const downloadURL = await getDownloadURL(fileRef);&#10;    &#10;    return downloadURL;&#10;  } catch (error) {&#10;    console.error(&quot;Error uploading avatar:&quot;, error);&#10;    throw new Error(&quot;Failed to upload avatar&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Upload CV PDF from Blob to Firebase Storage (private)&#10; * Used after generating PDF with Puppeteer&#10; * Path: /careermate-files/candidates/{candidateId}/cv/{fileName}&#10; */&#10;export async function uploadCVPDF(&#10;  candidateId: string, &#10;  pdfBlob: Blob, &#10;  customFileName?: string&#10;): Promise&lt;string&gt; {&#10;  try {&#10;    const timestamp = Date.now();&#10;    const fileName = customFileName &#10;      ? `${timestamp}_${customFileName}.pdf`&#10;      : `cv_${timestamp}.pdf`;&#10;    &#10;    const path = getCvStoragePath(candidateId, fileName);&#10;    const fileRef = ref(storage, path);&#10;    &#10;    // Upload blob with metadata&#10;    await uploadBytes(fileRef, pdfBlob, {&#10;      contentType: &quot;application/pdf&quot;,&#10;      customMetadata: {&#10;        candidateId,&#10;        uploadedAt: new Date().toISOString(),&#10;        type: &quot;generated-cv&quot;,&#10;      },&#10;    });&#10;    &#10;    const downloadURL = await getDownloadURL(fileRef);&#10;    &#10;    console.log(&quot;✅ CV PDF uploaded successfully:&quot;, downloadURL);&#10;    return downloadURL;&#10;  } catch (error) {&#10;    console.error(&quot;❌ Error uploading CV PDF:&quot;, error);&#10;    throw new Error(&quot;Failed to upload CV PDF to Firebase&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Delete file from Firebase Storage by storage path&#10; * @param storagePath - The full storage path (e.g., &quot;careermate-files/candidates/123/cv/file.pdf&quot;)&#10; */&#10;export async function deleteFile(storagePath: string): Promise&lt;void&gt; {&#10;  try {&#10;    const fileRef = ref(storage, storagePath);&#10;    await deleteObject(fileRef);&#10;    console.log(&quot;✅ File deleted successfully:&quot;, storagePath);&#10;  } catch (error) {&#10;    console.error(&quot;Error deleting file:&quot;, error);&#10;    throw new Error(&quot;Failed to delete file from Firebase Storage&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Delete file from Firebase Storage by download URL&#10; * Extracts the storage path from the URL and deletes the file&#10; * @param downloadUrl - The Firebase download URL&#10; */&#10;export async function deleteFileByUrl(downloadUrl: string): Promise&lt;void&gt; {&#10;  try {&#10;    const fileRef = ref(storage, downloadUrl);&#10;    await deleteObject(fileRef);&#10;    console.log(&quot;✅ File deleted successfully from URL&quot;);&#10;  } catch (error) {&#10;    console.error(&quot;Error deleting file by URL:&quot;, error);&#10;    throw new Error(&quot;Failed to delete file from Firebase Storage&quot;);&#10;  }&#10;}&#10;&#10;/**&#10; * Get download URL from Firebase Storage path&#10; * @param storagePath - The storage path&#10; * @returns Download URL&#10; */&#10;export async function getDownloadUrl(storagePath: string): Promise&lt;string&gt; {&#10;  try {&#10;    const storageRef = ref(storage, storagePath);&#10;    const url = await getDownloadURL(storageRef);&#10;    return url;&#10;  } catch (error) {&#10;    console.error(&quot;Error getting download URL:&quot;, error);&#10;    throw new Error(&quot;Failed to get download URL&quot;);&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import {&#13;&#10;  ref,&#13;&#10;  uploadBytes,&#13;&#10;  getDownloadURL,&#13;&#10;  deleteObject,&#13;&#10;} from &quot;firebase/storage&quot;;&#13;&#10;import { storage } from &quot;@/lib/firebase&quot;;&#13;&#10;&#13;&#10;// ===== Type Definitions =====&#13;&#10;export type CVType = &quot;CREATED&quot; | &quot;UPLOADED&quot;;&#13;&#10;export type CVSource = &quot;upload&quot; | &quot;builder&quot; | &quot;draft&quot;;&#13;&#10;export type CVVisibility = &quot;public&quot; | &quot;private&quot;;&#13;&#10;export type CVParsedStatus = &quot;processing&quot; | &quot;ready&quot; | &quot;failed&quot;;&#13;&#10;export type CVStatus = &quot;DRAFT&quot; | &quot;READY&quot;;&#13;&#10;&#13;&#10;// ===== CV Interface =====&#13;&#10;export interface CV {&#13;&#10;  // Core fields (always present)&#13;&#10;  id: string;&#13;&#10;  name: string;&#13;&#10;  type: CVType;&#13;&#10;  source?: CVSource; // Optional for compatibility with legacy components&#13;&#10;  createdAt: string; // ISO string&#13;&#10;  updatedAt: string; // ISO string&#13;&#10;  size?: number; // bytes (optional)&#13;&#10;  fileSize?: string; // formatted size (e.g., &quot;1.2 MB&quot;) (optional)&#13;&#10;  isDefault: boolean;&#13;&#10;  visibility?: CVVisibility; // Optional&#13;&#10;  privacy?: CVVisibility; // alias for visibility (optional, for compatibility)&#13;&#10;  downloadUrl: string;&#13;&#10;  fileUrl?: string; // alias for downloadUrl (optional, for compatibility)&#13;&#10;  userId?: string; // Optional&#13;&#10;  candidateId?: string; // Optional&#13;&#10;  storagePath: string; // path in Firebase Storage&#13;&#10;  parsedStatus?: CVParsedStatus; // Optional for UI display&#13;&#10;  status: CVStatus; // DRAFT or READY&#13;&#10;}&#13;&#10;&#13;&#10;// ===== Constants =====&#13;&#10;const CV_ROOT = 'careermate-files/candidates';&#13;&#10;const CV_SEPARATOR = '_CM_';&#13;&#10;&#13;&#10;// ===== Helper Functions =====&#13;&#10;&#13;&#10;/**&#13;&#10; * Sanitize file name: remove unsafe characters, replace spaces with underscores&#13;&#10; * &#13;&#10; * @param fileName - Original file name&#13;&#10; * @returns Sanitized file name&#13;&#10; * &#13;&#10; * @example&#13;&#10; * sanitizeFileName(&quot;My CV (final)!.pdf&quot;) // → &quot;My_CV_final.pdf&quot;&#13;&#10; * sanitizeFileName(&quot;Résumé 2024.pdf&quot;) // → &quot;Resume_2024.pdf&quot;&#13;&#10; */&#13;&#10;function sanitizeFileName(fileName: string): string {&#13;&#10;  if (!fileName) {&#13;&#10;    return 'file';&#13;&#10;  }&#13;&#10;&#13;&#10;  // Get extension first&#13;&#10;  const lastDotIndex = fileName.lastIndexOf('.');&#13;&#10;  let nameWithoutExt: string;&#13;&#10;  let extension: string;&#13;&#10;&#13;&#10;  if (lastDotIndex &gt; 0) {&#13;&#10;    nameWithoutExt = fileName.substring(0, lastDotIndex);&#13;&#10;    extension = fileName.substring(lastDotIndex + 1);&#13;&#10;  } else {&#13;&#10;    nameWithoutExt = fileName;&#13;&#10;    extension = 'pdf';&#13;&#10;  }&#13;&#10;&#13;&#10;  // Remove special characters, replace spaces with underscores&#13;&#10;  const sanitized = nameWithoutExt&#13;&#10;    .normalize('NFD') // Normalize unicode characters&#13;&#10;    .replace(/[\u0300-\u036f]/g, '') // Remove diacritics&#13;&#10;    .replace(/[^a-zA-Z0-9\s\-_]/g, '') // Remove special chars except space, hyphen, underscore&#13;&#10;    .replace(/\s+/g, '_') // Replace spaces with underscores&#13;&#10;    .replace(/_+/g, '_') // Replace multiple underscores with single&#13;&#10;    .trim();&#13;&#10;&#13;&#10;  return sanitized ? `${sanitized}.${extension}` : `file.${extension}`;&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * Generate storage file name with timestamp&#13;&#10; * Format: [originalName]_CM_[timestamp].[ext]&#13;&#10; * &#13;&#10; * @param originalFileName - Original file name from user&#13;&#10; * @returns Storage file name with timestamp&#13;&#10; * &#13;&#10; * @example&#13;&#10; * generateStorageName(&quot;CV.pdf&quot;) // → &quot;CV_CM_1732702341123.pdf&quot;&#13;&#10; * generateStorageName(&quot;My Resume.pdf&quot;) // → &quot;My_Resume_CM_1732702341123.pdf&quot;&#13;&#10; */&#13;&#10;function generateStorageName(originalFileName: string): string {&#13;&#10;  if (!originalFileName) {&#13;&#10;    return `file${CV_SEPARATOR}${Date.now()}.pdf`;&#13;&#10;  }&#13;&#10;&#13;&#10;  try {&#13;&#10;    // Sanitize first&#13;&#10;    const sanitized = sanitizeFileName(originalFileName);&#13;&#10;&#13;&#10;    // Extract base name and extension&#13;&#10;    const lastDotIndex = sanitized.lastIndexOf('.');&#13;&#10;    &#13;&#10;    let baseName: string;&#13;&#10;    let extension: string;&#13;&#10;&#13;&#10;    if (lastDotIndex &gt; 0) {&#13;&#10;      baseName = sanitized.substring(0, lastDotIndex);&#13;&#10;      extension = sanitized.substring(lastDotIndex + 1);&#13;&#10;    } else {&#13;&#10;      baseName = sanitized;&#13;&#10;      extension = 'pdf';&#13;&#10;    }&#13;&#10;&#13;&#10;    // Generate timestamp&#13;&#10;    const timestamp = Date.now();&#13;&#10;&#13;&#10;    // Build storage name: [baseName]_CM_[timestamp].[ext]&#13;&#10;    return `${baseName}${CV_SEPARATOR}${timestamp}.${extension}`;&#13;&#10;  } catch (error) {&#13;&#10;    console.error('Error generating storage name:', error);&#13;&#10;    return `file${CV_SEPARATOR}${Date.now()}.pdf`;&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * Extract original file name from storage name&#13;&#10; * Removes the _CM_[timestamp] suffix&#13;&#10; * &#13;&#10; * @param storageName - The storage file name (e.g., &quot;CV_CM_1732702341123.pdf&quot;)&#13;&#10; * @returns Original file name (e.g., &quot;CV.pdf&quot;)&#13;&#10; * &#13;&#10; * @example&#13;&#10; * extractOriginalName(&quot;CV_CM_1732702341123.pdf&quot;) // → &quot;CV.pdf&quot;&#13;&#10; * extractOriginalName(&quot;My_Resume_CM_1732702341123.pdf&quot;) // → &quot;My_Resume.pdf&quot;&#13;&#10; * extractOriginalName(&quot;CV.pdf&quot;) // → &quot;CV.pdf&quot; (no separator, return as-is)&#13;&#10; */&#13;&#10;export function extractOriginalName(storageName: string): string {&#13;&#10;  if (!storageName) {&#13;&#10;    return 'Unknown.pdf';&#13;&#10;  }&#13;&#10;&#13;&#10;  // If no separator found, return as-is&#13;&#10;  if (!storageName.includes(CV_SEPARATOR)) {&#13;&#10;    return storageName;&#13;&#10;  }&#13;&#10;&#13;&#10;  try {&#13;&#10;    // Split at _CM_ separator&#13;&#10;    const parts = storageName.split(CV_SEPARATOR);&#13;&#10;    &#13;&#10;    if (parts.length &lt; 2) {&#13;&#10;      return storageName;&#13;&#10;    }&#13;&#10;&#13;&#10;    // Get base name (before _CM_)&#13;&#10;    const baseName = parts[0];&#13;&#10;    &#13;&#10;    // Get the extension from the storage name (after timestamp)&#13;&#10;    const lastPart = parts[parts.length - 1]; // &quot;1732702341123.pdf&quot;&#13;&#10;    const extMatch = lastPart.match(/\.([^.]+)$/);&#13;&#10;    const extension = extMatch ? extMatch[1] : 'pdf';&#13;&#10;&#13;&#10;    // Reconstruct: baseName + extension&#13;&#10;    return `${baseName}.${extension}`;&#13;&#10;  } catch (error) {&#13;&#10;    console.error('Error extracting original name:', error);&#13;&#10;    return storageName;&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * Format file size from bytes to human-readable&#13;&#10; */&#13;&#10;export function formatFileSize(bytes: number): string {&#13;&#10;  if (bytes === 0) return &quot;0 Bytes&quot;;&#13;&#10;  const k = 1024;&#13;&#10;  const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;];&#13;&#10;  const i = Math.floor(Math.log(bytes) / Math.log(k));&#13;&#10;  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + &quot; &quot; + sizes[i];&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * Generate CV storage path&#13;&#10; * Path: careermate-files/candidates/{candidateId}/{filename}&#13;&#10; */&#13;&#10;function getCvStoragePath(candidateId: string, filename: string): string {&#13;&#10;  return `${CV_ROOT}/${candidateId}/cv/${filename}`;&#13;&#10;}&#13;&#10;&#13;&#10;// ===== Firebase Storage Functions =====&#13;&#10;&#13;&#10;/**&#13;&#10; * Upload CV file to Firebase Storage with metadata&#13;&#10; * Path: candidates/{candidateId}/{storageName}&#13;&#10; * &#13;&#10; * @param candidateId - The candidate's ID&#13;&#10; * @param file - The CV file to upload&#13;&#10; * @returns Metadata object with originalName and storageName&#13;&#10; * &#13;&#10; * @example&#13;&#10; * const result = await uploadCvFile(&quot;123&quot;, file);&#13;&#10; * // result.originalName → &quot;CV.pdf&quot;&#13;&#10; * // result.storageName → &quot;CV_CM_1732702341123.pdf&quot;&#13;&#10; * // result.downloadUrl → &quot;https://firebasestorage...&quot;&#13;&#10; * // result.fullPath → &quot;candidates/123/CV_CM_1732702341123.pdf&quot;&#13;&#10; */&#13;&#10;export async function uploadCvFile(candidateId: string, file: File) {&#13;&#10;  console.log(&quot; Uploading CV start:&quot;, {&#13;&#10;    fileName: file.name,&#13;&#10;    fileSize: formatFileSize(file.size),&#13;&#10;    fileType: file.type,&#13;&#10;    candidateId,&#13;&#10;  });&#13;&#10;&#13;&#10;  // Validate Firebase Storage configuration&#13;&#10;  const bucket = process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET;&#13;&#10;  if (!bucket) {&#13;&#10;    console.error(&quot;❌ NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET is not defined in environment variables&quot;);&#13;&#10;    throw new Error(&quot;Firebase Storage bucket is not configured. Please check your .env file.&quot;);&#13;&#10;  }&#13;&#10;&#13;&#10;  // Validate bucket format&#13;&#10;  if (!bucket.includes('.firebasestorage.app') &amp;&amp; !bucket.includes('.appspot.com')) {&#13;&#10;    console.warn(&quot;⚠️ Firebase Storage bucket format might be invalid:&quot;, bucket);&#13;&#10;    console.warn(&quot;Expected format: 'project-id.firebasestorage.app' or 'project-id.appspot.com'&quot;);&#13;&#10;  }&#13;&#10;&#13;&#10;  try {&#13;&#10;    // Store original name&#13;&#10;    const originalName = file.name;&#13;&#10;    &#13;&#10;    // Generate storage name: [originalName]_CM_[timestamp].[ext]&#13;&#10;    const storageName = generateStorageName(originalName);&#13;&#10;    &#13;&#10;    console.log(&quot; File names:&quot;, {&#13;&#10;      original: originalName,&#13;&#10;      storage: storageName,&#13;&#10;    });&#13;&#10;    &#13;&#10;    // Build storage path&#13;&#10;    const fullPath = getCvStoragePath(candidateId, storageName);&#13;&#10;    &#13;&#10;    console.log(&quot; Storage path:&quot;, fullPath);&#13;&#10;    &#13;&#10;    // Upload to Firebase Storage&#13;&#10;    const storageRef = ref(storage, fullPath);&#13;&#10;    &#13;&#10;    console.log(&quot;⬆️ Uploading bytes to Firebase Storage...&quot;);&#13;&#10;    const uploadResult = await uploadBytes(storageRef, file, {&#13;&#10;      contentType: file.type,&#13;&#10;      customMetadata: {&#13;&#10;        candidateId,&#13;&#10;        originalName: originalName,&#13;&#10;        storageName: storageName,&#13;&#10;        uploadedAt: new Date().toISOString(),&#13;&#10;      },&#13;&#10;    });&#13;&#10;    &#13;&#10;    console.log(&quot;✅ Upload bytes successful:&quot;, {&#13;&#10;      path: uploadResult.ref.fullPath,&#13;&#10;      size: uploadResult.metadata.size,&#13;&#10;    });&#13;&#10;    &#13;&#10;    // Get download URL with retry logic (Firebase propagation can be slow)&#13;&#10;    let downloadUrl: string | undefined;&#13;&#10;    let retries = 3;&#13;&#10;    let lastError: Error | undefined;&#13;&#10;&#13;&#10;    console.log(&quot; Fetching download URL...&quot;);&#13;&#10;    &#13;&#10;    while (retries &gt; 0 &amp;&amp; !downloadUrl) {&#13;&#10;      try {&#13;&#10;        downloadUrl = await getDownloadURL(storageRef);&#13;&#10;        console.log(&quot;✅ Download URL obtained:&quot;, downloadUrl);&#13;&#10;      } catch (error: any) {&#13;&#10;        lastError = error;&#13;&#10;        retries--;&#13;&#10;        &#13;&#10;        // Log detailed Firebase error&#13;&#10;        console.error(`⚠️ getDownloadURL attempt failed (${3 - retries}/3):`, {&#13;&#10;          code: error?.code,&#13;&#10;          message: error?.message,&#13;&#10;          serverResponse: error?.serverResponse,&#13;&#10;          customData: error?.customData,&#13;&#10;        });&#13;&#10;&#13;&#10;        // Check for common Firebase Storage errors&#13;&#10;        if (error?.code === 'storage/object-not-found') {&#13;&#10;          console.error(&quot;❌ Firebase Storage Error: Object not found. File might not have propagated yet.&quot;);&#13;&#10;        } else if (error?.code === 'storage/unauthorized') {&#13;&#10;          console.error(&quot;❌ Firebase Storage Error: Permission denied. Check Firebase Storage Rules:&quot;);&#13;&#10;          console.error(&quot;   Rules should allow: allow read, write: if request.auth != null;&quot;);&#13;&#10;        } else if (error?.code === 'storage/bucket-not-found') {&#13;&#10;          console.error(&quot;❌ Firebase Storage Error: Bucket not found. Check NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET:&quot;, bucket);&#13;&#10;        }&#13;&#10;&#13;&#10;        if (retries &gt; 0) {&#13;&#10;          console.log(`⏳ Retrying in 1 second... (${retries} attempts left)`);&#13;&#10;          await new Promise(resolve =&gt; setTimeout(resolve, 1000));&#13;&#10;        }&#13;&#10;      }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Final validation: Ensure downloadUrl is not undefined&#13;&#10;    if (!downloadUrl) {&#13;&#10;      console.error(&quot;❌ CRITICAL: Download URL is undefined after all retries&quot;);&#13;&#10;      console.error(&quot;Last error:&quot;, lastError);&#13;&#10;      throw new Error(&#13;&#10;        `Failed to get download URL after 3 attempts. ${&#13;&#10;          lastError?.message || 'Unknown error'&#13;&#10;        }. Check Firebase Storage Rules and bucket configuration.`&#13;&#10;      );&#13;&#10;    }&#13;&#10;&#13;&#10;    // Construct metadata object&#13;&#10;    const metadata = {&#13;&#10;      id: storageName,&#13;&#10;      name: originalName,&#13;&#10;      originalName: originalName,&#13;&#10;      storageName: storageName,&#13;&#10;      candidateId,&#13;&#10;      storagePath: fullPath,&#13;&#10;      fullPath: fullPath,&#13;&#10;      downloadUrl, // GUARANTEED to be defined here&#13;&#10;      type: 'UPLOADED' as const,&#13;&#10;      source: 'upload' as const,&#13;&#10;      status: 'READY' as const,&#13;&#10;      isDefault: false,&#13;&#10;      updatedAt: new Date().toISOString(),&#13;&#10;      createdAt: new Date().toISOString(),&#13;&#10;      size: file.size,&#13;&#10;      fileSize: formatFileSize(file.size),&#13;&#10;    };&#13;&#10;&#13;&#10;    console.log(&quot;✅ Firebase upload complete:&quot;, {&#13;&#10;      originalName: metadata.originalName,&#13;&#10;      storageName: metadata.storageName,&#13;&#10;      downloadUrl: metadata.downloadUrl,&#13;&#10;      fullPath: metadata.fullPath,&#13;&#10;    });&#13;&#10;&#13;&#10;    return metadata;&#13;&#10;  } catch (error: any) {&#13;&#10;    console.error(&quot;❌ Error uploading CV file:&quot;, {&#13;&#10;      error,&#13;&#10;      code: error?.code,&#13;&#10;      message: error?.message,&#13;&#10;      fileName: file.name,&#13;&#10;      candidateId,&#13;&#10;    });&#13;&#10;&#13;&#10;    // Re-throw with more context&#13;&#10;    throw new Error(&#13;&#10;      `Failed to upload CV file: ${error?.message || 'Unknown error'}. ${&#13;&#10;        error?.code ? `Error code: ${error.code}` : ''&#13;&#10;      }`&#13;&#10;    );&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;/**&#10; * Upload avatar to Firebase Storage (public)&#10; * Path: /careermate-files/candidates/{userId}/avatar/{fileName}&#10; * &#10; * @returns Storage path (NOT download URL) to be saved in database&#10; */&#10;export async function uploadAvatar(userId: string, file: File): Promise&lt;string&gt; {&#10;  try {&#10;    // Extract file extension properly&#10;    const ext = file.name.split('.').pop()?.toLowerCase() || 'jpg';&#10;    &#10;    // Sanitize filename: remove extension and special chars, then add timestamp&#10;    const sanitizedName = file.name&#10;      .replace(/\.[^/.]+$/, '') // Remove extension&#10;      .replace(/[^a-zA-Z0-9_-]/g, '_') // Replace special chars with underscore&#10;      .substring(0, 50); // Limit length&#10;    &#10;    const fileName = `${Date.now()}_${sanitizedName}.${ext}`;&#10;    const storagePath = `careermate-files/candidates/${userId}/avatar/${fileName}`;&#10;    const fileRef = ref(storage, storagePath);&#10;    &#10;    await uploadBytes(fileRef, file);&#10;    &#10;    // Return storage path, not download URL&#10;    // Frontend will call getFileUrl(storagePath) when needed&#10;    return storagePath;&#10;  } catch (error) {&#10;    console.error(&quot;Error uploading avatar:&quot;, error);&#10;    throw new Error(&quot;Failed to upload avatar&quot;);&#10;  }&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * Upload CV PDF from Blob to Firebase Storage (private)&#13;&#10; * Used after generating PDF with Puppeteer&#13;&#10; * Path: /careermate-files/candidates/{candidateId}/cv/{fileName}&#13;&#10; */&#13;&#10;export async function uploadCVPDF(&#13;&#10;  candidateId: string, &#13;&#10;  pdfBlob: Blob, &#13;&#10;  customFileName?: string&#13;&#10;): Promise&lt;string&gt; {&#13;&#10;  try {&#13;&#10;    const timestamp = Date.now();&#13;&#10;    const fileName = customFileName &#13;&#10;      ? `${timestamp}_${customFileName}.pdf`&#13;&#10;      : `cv_${timestamp}.pdf`;&#13;&#10;    &#13;&#10;    const path = getCvStoragePath(candidateId, fileName);&#13;&#10;    const fileRef = ref(storage, path);&#13;&#10;    &#13;&#10;    // Upload blob with metadata&#13;&#10;    await uploadBytes(fileRef, pdfBlob, {&#13;&#10;      contentType: &quot;application/pdf&quot;,&#13;&#10;      customMetadata: {&#13;&#10;        candidateId,&#13;&#10;        uploadedAt: new Date().toISOString(),&#13;&#10;        type: &quot;generated-cv&quot;,&#13;&#10;      },&#13;&#10;    });&#13;&#10;    &#13;&#10;    const downloadURL = await getDownloadURL(fileRef);&#13;&#10;    &#13;&#10;    console.log(&quot;✅ CV PDF uploaded successfully:&quot;, downloadURL);&#13;&#10;    return downloadURL;&#13;&#10;  } catch (error) {&#13;&#10;    console.error(&quot;❌ Error uploading CV PDF:&quot;, error);&#13;&#10;    throw new Error(&quot;Failed to upload CV PDF to Firebase&quot;);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * Delete file from Firebase Storage by storage path&#13;&#10; * @param storagePath - The full storage path (e.g., &quot;careermate-files/candidates/123/cv/file.pdf&quot;)&#13;&#10; */&#13;&#10;export async function deleteFile(storagePath: string): Promise&lt;void&gt; {&#13;&#10;  try {&#13;&#10;    const fileRef = ref(storage, storagePath);&#13;&#10;    await deleteObject(fileRef);&#13;&#10;    console.log(&quot;✅ File deleted successfully:&quot;, storagePath);&#13;&#10;  } catch (error) {&#13;&#10;    console.error(&quot;Error deleting file:&quot;, error);&#13;&#10;    throw new Error(&quot;Failed to delete file from Firebase Storage&quot;);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * Delete file from Firebase Storage by download URL&#13;&#10; * Extracts the storage path from the URL and deletes the file&#13;&#10; * @param downloadUrl - The Firebase download URL&#13;&#10; */&#13;&#10;export async function deleteFileByUrl(downloadUrl: string): Promise&lt;void&gt; {&#13;&#10;  try {&#13;&#10;    const fileRef = ref(storage, downloadUrl);&#13;&#10;    await deleteObject(fileRef);&#13;&#10;    console.log(&quot;✅ File deleted successfully from URL&quot;);&#13;&#10;  } catch (error) {&#13;&#10;    console.error(&quot;Error deleting file by URL:&quot;, error);&#13;&#10;    throw new Error(&quot;Failed to delete file from Firebase Storage&quot;);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;/**&#13;&#10; * Get download URL from Firebase Storage path&#13;&#10; * @param storagePath - The storage path&#13;&#10; * @returns Download URL&#13;&#10; */&#13;&#10;export async function getDownloadUrl(storagePath: string): Promise&lt;string&gt; {&#13;&#10;  try {&#13;&#10;    const storageRef = ref(storage, storagePath);&#13;&#10;    const url = await getDownloadURL(storageRef);&#13;&#10;    return url;&#13;&#10;  } catch (error) {&#13;&#10;    console.error(&quot;Error getting download URL:&quot;, error);&#13;&#10;    throw new Error(&quot;Failed to get download URL&quot;);&#13;&#10;  }&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>